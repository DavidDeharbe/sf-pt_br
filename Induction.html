<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Induction</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Induction</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Indução: Prova por Indução</h1>

<div class="paragraph"> </div>

 A próxima linha importa todas as nossas definições do capítulo anterior. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">Basics</span>.<br/>

<br/>
</div>

<div class="doc">
For it to work, you need to use <span class="inlinecode"><span class="id" title="var">coqc</span></span> to compile <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>
    into <span class="inlinecode"><span class="id" title="var">Basics.vo</span></span>.  (This is like making a .class file from a .java
    file, or a .o file from a .c file.)

<div class="paragraph"> </div>

    Here are two ways to compile your code:

<div class="paragraph"> </div>

<ul class="doclist">
<li> CoqIDE:

<div class="paragraph"> </div>

         Open <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>.
         In the "Compile" menu, click on "Compile Buffer".

<div class="paragraph"> </div>


</li>
<li> Command line:

<div class="paragraph"> </div>

         Run <span class="inlinecode"><span class="id" title="var">coqc</span></span> <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    
<div class="paragraph"> </div>

<a name="lab2"></a><h1 class="section">Nomeando Casos</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Dalay</span></span> The fact that there is no explicit command for moving from
    one branch of a case analysis to the next can make proof scripts
    rather hard to read.  In larger proofs, with nested case analyses,
    it can even become hard to stay oriented when you're sitting with
    Coq and stepping through the proof.  (Imagine trying to remember
    that the first five subgoals belong to the inner case analysis and
    the remaining seven cases are what remains of the outer one...)
    Disciplined use of indentation and comments can help, but a better
    way is to use the <span class="inlinecode"><span class="id" title="var">Case</span></span> tactic. 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Case</span></span> (<i>Caso</i>) não é predefinido no Coq: é preciso definí-lo.
    Não existe necessidade de entender os detalhes desta definição -- você 
    pode somente 
    pular a definição e ir direto para o exemplo que a segue.  <i>Case</i> utiliza algumas
    ferramentas do Coq que ainda não foram discutidas -- a biblioteca de
    cadeias de caracteres (somente para a sintaxe concreta das cadeias de caracteres citadas) e o comando
    <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span>, que permite a declaração de táticas costumizadas.  Muitos elogios
    para Aaron Bohannon por esse ótimo truque! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="var">String</span>. <span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">string_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">move_to_top</span> <span class="id" title="var">x</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">reverse</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">H</span> : <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">try</span> <span class="id" title="tactic">move</span> <span class="id" title="var">x</span> <span class="id" title="keyword">after</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "assert_eq" <span class="id" title="var">ident</span>(<span class="id" title="var">x</span>) <span class="id" title="keyword">constr</span>(<span class="id" title="var">v</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">x</span> = <span class="id" title="var">v</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">reflexivity</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "Case_aux" <span class="id" title="var">ident</span>(<span class="id" title="var">x</span>) <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">first</span> [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">x</span> := <span class="id" title="var">name</span>); <span class="id" title="var">move_to_top</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">assert_eq</span> <span class="id" title="var">x</span> <span class="id" title="var">name</span>; <span class="id" title="var">move_to_top</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| <span class="id" title="tactic">fail</span> 1 "because we are working on a different case" ].<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "Case" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">Case</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSSSSCase</span> <span class="id" title="var">name</span>.<br/>
</div>

<div class="doc">
Aqui está um exemplo de como <span class="inlinecode"><span class="id" title="var">Case</span></span> é usado.  Veja a prova a seguir e
    observe como o contexto muda. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_true_elim1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">true</span> → <span class="id" title="var">b</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "b = true". &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "b = false". &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"><span class="id" title="var">Case</span></span> does something very straightforward: It simply adds a
    string that we choose (tagged with the identifier "Case") to the
    context for the current goal.  When subgoals are generated, this
    string is carried over into their contexts.  When the last of
    these subgoals is finally proved and the next top-level goal
    becomes active, this string will no longer appear in the context
    and we will be able to see that the case where we introduced it is
    complete.  Also, as a sanity check, if we try to execute a new
    <span class="inlinecode"><span class="id" title="var">Case</span></span> tactic while the string left by the previous one is still
    in the context, we get a nice clear error message.

<div class="paragraph"> </div>

    Para as análises aninhadas de casos (por exemplo, quando nós queremos 
    usar um <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> para resolver uma meta que também foi gerada 
    por um <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>), há uma tática de "subcaso" <span class="inlinecode"><span class="id" title="var">SCase</span></span>. 
<div class="paragraph"> </div>

<a name="lab3"></a><h4 class="section">Exercício 2: ** (andb_true_elim2)</h4>
 Provar <span class="inlinecode"><span class="id" title="var">andb_true_elim2</span></span>, marcando casos (e subcasos) quando
    você usar <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_true_elim2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">true</span> → <span class="id" title="var">c</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Não existem regras rígidas e rápidas para como as provas devem ser
 formatadas no Coq -- em particular, sobre onde as linhas devem ser
 quebradas e como seções da prova deveriam ser indentadas para indicar
 suas estruturas aninhadas. Porém, se os lugares onde múltiplas metas
 são geradas estão marcadas com táticas <span class="inlinecode"><span class="id" title="var">Case</span></span> explícitas no início
 das linhas, então a prova será legível independentemente de quais escolhas
 foram feitas sobre outros aspectos do layout.

<div class="paragraph"> </div>

      Este é um bom lugar para mencionar um outro (possivelmente óbvio) conselho
      sobre comprimentos de linha. Usuários iniciantes em Coq às vezes tendem
      aos extremos, seja escrevendo cada tática em uma nova linha ou provas
      inteiras em uma linha. Um bom estilo encontra-se entre os dois extremos.
      Em particular, uma convenção razoável é limitar-se a linhas de 80
      caracteres. Linhas com mais do que isso são difíceis de ler e podem ser
      inconvenientes para exibir e imprimir. Muitos editores têm recursos que
      ajudam a cumprir isso.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_0_r_firsttry : forall n:nat,
  n + 0 = n.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Proof.
  intros n.
  simpl. Abort.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_0_r_secondtry : forall n:nat,
  n + 0 = n.
Proof.
  intros n. destruct n as <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>.
  Case "n = 0".
    reflexivity.   Case "n = S n'".
    simpl.       Abort.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_0_r : forall n:nat, n + 0 = n.
Proof.
  intros n. induction n as <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>.
  Case "n = 0".     reflexivity.
  Case "n = S n'".  simpl. rewrite -&gt; IHn'. reflexivity.  Qed.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem minus_diag : forall n,
  minus n n = 0.
Proof.
    intros n. induction n as <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>.
  Case "n = 0".
    simpl. reflexivity.
  Case "n = S n'".
    simpl. rewrite -&gt; IHn'. reflexivity.  Qed.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem mult_0_r : forall n:nat,
  n * 0 = 0.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem plus_n_Sm : forall n m : nat, 
  S (n + m) = n + (S m).
Proof. 
   Admitted.

<div class="paragraph"> </div>

Theorem plus_comm : forall n m : nat,
  n + m = m + n.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem plus_assoc : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Fixpoint double (n:nat) :=
  match n with
  | O =&gt; O
  | S n' =&gt; S (S (double n'))
  end.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Lemma double_plus : forall n, double n = n + n .
Proof.  
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem mult_0_plus' : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  assert (H: 0 + n = n). 
    Case "Proof of assertion". reflexivity.
  rewrite -&gt; H.
  reflexivity.  Qed.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
    rewrite -&gt; plus_comm.
  Abort.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n).
    Case "Proof of assertion".
    rewrite -&gt; plus_comm. reflexivity.
  rewrite -&gt; H. reflexivity.  Qed.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_swap : forall n m p : nat, 
  n + (m + p) = m + (n + p).
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem mult_comm : forall m n : nat,
 m * n = n * m.
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem evenb_n__oddb_Sn : forall n : nat,
  evenb n = negb (evenb (S n)).
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem ble_nat_refl : forall n:nat,
  true = ble_nat n n.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem zero_nbeq_S : forall n:nat,
  beq_nat 0 (S n) = false.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem andb_false_r : forall b : bool,
  andb b false = false.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem plus_ble_compat_l : forall n m p : nat, 
  ble_nat n m = true -&gt; ble_nat (p + n) (p + m) = true.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem S_nbeq_0 : forall n:nat,
  beq_nat (S n) 0 = false.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem mult_1_l : forall n:nat, 1 * n = n.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem all3_spec : forall b c : bool,
    orb
      (andb b c)
      (orb (negb b)
               (negb c))
  = true.
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
Proof.
   Admitted.

<div class="paragraph"> </div>

Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p.
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem beq_nat_refl : forall n : nat, 
  true = beq_nat n n.
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_swap' : forall n m p : nat, 
  n + (m + p) = m + (n + p).
Proof.
   Admitted.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof. intros n m p. induction n as <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>. reflexivity. 
  simpl. rewrite -&gt; IHn'. reflexivity.  Qed.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

Theorem plus_assoc'' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  intros n m p. induction n as <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>. 
  Case "n = 0".
    reflexivity. 
  Case "n = S n'".
    simpl. rewrite -&gt; IHn'. reflexivity.   Qed.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>


</div>
<div class="code">
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>