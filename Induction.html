<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Induction</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Induction</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Indução: Prova por Indução</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Claudia</span></span> The next line imports all of our definitions from the
    previous chapter. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">Basics</span>.<br/>

<br/>
</div>

<div class="doc">
For it to work, you need to use <span class="inlinecode"><span class="id" title="var">coqc</span></span> to compile <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>
    into <span class="inlinecode"><span class="id" title="var">Basics.vo</span></span>.  (This is like making a .class file from a .java
    file, or a .o file from a .c file.)

<div class="paragraph"> </div>

    Here are two ways to compile your code:

<div class="paragraph"> </div>

<ul class="doclist">
<li> CoqIDE:

<div class="paragraph"> </div>

         Open <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>.
         In the "Compile" menu, click on "Compile Buffer".

<div class="paragraph"> </div>


</li>
<li> Command line:

<div class="paragraph"> </div>

         Run <span class="inlinecode"><span class="id" title="var">coqc</span></span> <span class="inlinecode"><span class="id" title="var">Basics.v</span></span>

</li>
</ul>

<div class="paragraph"> </div>

    
<div class="paragraph"> </div>

<a name="lab2"></a><h1 class="section">Nomeando Casos</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Dalay</span></span> The fact that there is no explicit command for moving from
    one branch of a case analysis to the next can make proof scripts
    rather hard to read.  In larger proofs, with nested case analyses,
    it can even become hard to stay oriented when you're sitting with
    Coq and stepping through the proof.  (Imagine trying to remember
    that the first five subgoals belong to the inner case analysis and
    the remaining seven cases are what remains of the outer one...)
    Disciplined use of indentation and comments can help, but a better
    way is to use the <span class="inlinecode"><span class="id" title="var">Case</span></span> tactic. 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Diego</span></span> <span class="inlinecode"><span class="id" title="var">Case</span></span> is not built into Coq: we need to define it ourselves.
    There is no need to understand how it works -- you can just skip
    over the definition to the example that follows.  It uses some
    facilities of Coq that we have not discussed -- the string
    library (just for the concrete syntax of quoted strings) and the
    <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> command, which allows us to declare custom tactics.  Kudos
    to Aaron Bohannon for this nice hack! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="var">String</span>. <span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">string_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">move_to_top</span> <span class="id" title="var">x</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">reverse</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">H</span> : <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">try</span> <span class="id" title="tactic">move</span> <span class="id" title="var">x</span> <span class="id" title="keyword">after</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "assert_eq" <span class="id" title="var">ident</span>(<span class="id" title="var">x</span>) <span class="id" title="keyword">constr</span>(<span class="id" title="var">v</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">x</span> = <span class="id" title="var">v</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">H</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">reflexivity</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "Case_aux" <span class="id" title="var">ident</span>(<span class="id" title="var">x</span>) <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">first</span> [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">x</span> := <span class="id" title="var">name</span>); <span class="id" title="var">move_to_top</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">assert_eq</span> <span class="id" title="var">x</span> <span class="id" title="var">name</span>; <span class="id" title="var">move_to_top</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;| <span class="id" title="tactic">fail</span> 1 "because we are working on a different case" ].<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "Case" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">Case</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSSSCase</span> <span class="id" title="var">name</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "SSSSSSSCase" <span class="id" title="keyword">constr</span>(<span class="id" title="var">name</span>) := <span class="id" title="var">Case_aux</span> <span class="id" title="var">SSSSSSSCase</span> <span class="id" title="var">name</span>.<br/>
</div>

<div class="doc">
Here's an example of how <span class="inlinecode"><span class="id" title="var">Case</span></span> is used.  Step through the
   following proof and observe how the context changes. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_true_elim1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">true</span> → <span class="id" title="var">b</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "b = true". &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "b = false". &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"><span class="id" title="var">Case</span></span> does something very straightforward: It simply adds a
    string that we choose (tagged with the identifier "Case") to the
    context for the current goal.  When subgoals are generated, this
    string is carried over into their contexts.  When the last of
    these subgoals is finally proved and the next top-level goal
    becomes active, this string will no longer appear in the context
    and we will be able to see that the case where we introduced it is
    complete.  Also, as a sanity check, if we try to execute a new
    <span class="inlinecode"><span class="id" title="var">Case</span></span> tactic while the string left by the previous one is still
    in the context, we get a nice clear error message.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">Renan</span></span> For nested case analyses (e.g., when we want to use a <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>
    to solve a goal that has itself been generated by a <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>),
    there is an <span class="inlinecode"><span class="id" title="var">SCase</span></span> ("subcase") tactic. 
<div class="paragraph"> </div>

<a name="lab3"></a><h4 class="section">Exercício 2: ** (andb_true_elim2)</h4>
 Prove <span class="inlinecode"><span class="id" title="var">andb_true_elim2</span></span>, marking cases (and subcases) when
    you use <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_true_elim2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">true</span> → <span class="id" title="var">c</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Não existem regras rígidas e rápidas para como as provas devem ser
 formatadas no Coq -- em particular, sobre onde as linhas devem ser
 quebradas e como seções da prova deveriam ser indentadas para indicar
 suas estruturas aninhadas. Porém, se os lugares onde múltiplas metas
 são geradas estão marcadas com táticas <span class="inlinecode"><span class="id" title="var">Case</span></span> explícitas no início
 das linhas, então a prova será legível independentemente de quais escolhas
 foram feitas sobre outros aspectos do layout.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">Claudia</span></span> This is a good place to mention one other piece of (possibly
    obvious) advice about line lengths.  Beginning Coq users sometimes
    tend to the extremes, either writing each tactic on its own line
    or entire proofs on one line.  Good style lies somewhere in the
    middle.  In particular, one reasonable convention is to limit
    yourself to 80-character lines.  Lines longer than this are hard
    to read and can be inconvenient to display and print.  Many
    editors have features that help enforce this. 
<div class="paragraph"> </div>

<a name="lab4"></a><h1 class="section">Prova por Indução</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Dalay</span></span>We proved in the last chapter that <span class="inlinecode">0</span> is a neutral element
    for <span class="inlinecode">+</span> on the left using a simple argument.  The fact that it is
    also a neutral element on the <i>right</i>... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_0_r_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
... cannot be proved in the same simple way.  Just applying
  <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> doesn't work: the <span class="inlinecode"><span class="id" title="var">n</span></span> in <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> is an arbitrary
  unknown number, so the <span class="inlinecode"><span class="id" title="keyword">match</span></span> in the definition of <span class="inlinecode">+</span> can't be
  simplified.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Diego</span></span> And reasoning by cases using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> doesn't get us much
   further: the branch of the case analysis where we assume <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>
   goes through, but in the branch where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> for some <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> we
   get stuck in exactly the same way.  We could use <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> to
   get one step further, but since <span class="inlinecode"><span class="id" title="var">n</span></span> can be arbitrarily large, if we
   try to keep on like this we'll never be done. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_0_r_secondtry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "n = 0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. &nbsp;&nbsp;<span class="id" title="var">Case</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Francisco</span></span> To prove such facts -- indeed, to prove most interesting
    facts about numbers, lists, and other inductively defined sets --
    we need a more powerful reasoning principle: <i>induction</i>.

<div class="paragraph"> </div>

    Recall (from high school) the principle of induction over natural
    numbers: If <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span> is some proposition involving a natural number
    <span class="inlinecode"><span class="id" title="var">n</span></span> and we want to show that P holds for <i>all</i> numbers <span class="inlinecode"><span class="id" title="var">n</span></span>, we can
    reason like this:

<div class="paragraph"> </div>

<ul class="doclist">
<li> show that <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">O</span>)</span> holds;

</li>
<li> show that, for any <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>, if <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n&acute;</span>)</span> holds, then so does
           <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span>)</span>;

</li>
<li> conclude that <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span> holds for all <span class="inlinecode"><span class="id" title="var">n</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">Renan</span></span> In Coq, the steps are the same but the order is backwards: we
    begin with the goal of proving <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span> for all <span class="inlinecode"><span class="id" title="var">n</span></span> and break it
    down (by applying the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic) into two separate
    subgoals: first showing <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">O</span>)</span> and then showing <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n&acute;</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">S</span></span>
    <span class="inlinecode"><span class="id" title="var">n&acute;</span>)</span>.  Here's how this works for the theorem we are trying to
    prove at the moment: 
<div class="paragraph"> </div>

<a name="lab7"></a><h3 class="section"> </h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_0_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>, <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "n = 0". <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "n = S n'". <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Assim como <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>, a tática <span class="inlinecode"><span class="id" title="tactic">induction</span></span> usa a cláusula
 <span class="inlinecode"><span class="id" title="keyword">as</span>...</span> para especificar os nomes das variáveis que serão
 introduzidas nas submetas. No primeiro ramo, <span class="inlinecode"><span class="id" title="var">n</span></span> é substituída por
 <span class="inlinecode">0</span> e a meta se torna  <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, que, em seguida, é
 simplificada. No segundo ramo, <span class="inlinecode"><span class="id" title="var">n</span></span> é substituído por <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> e a
 hipótese <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> é adicionada no contexto (com o nome <span class="inlinecode"><span class="id" title="var">IHn&acute;</span></span>:
 Inductive Hypothesis for <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>). O objetivo se torna, neste
 caso, <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>, que é simplificado para <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">n&acute;</span></span> <span class="inlinecode">+</span> <span class="inlinecode">0)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span>
 <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> devido à hipótese indutiva. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">minus_diag</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">minus</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "n = 0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h4 class="section">Exercício: ** (basic_induction)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Claudia</span></span> Prove the following lemmas using induction. You might need
    previously proven results. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> × 0 = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_Sm</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">S</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) = <span class="id" title="var">n</span> + (<span class="id" title="var">S</span> <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_comm</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab9"></a><h4 class="section">Exercício: ** (double_plus)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Dalay</span></span> Consider the following function, which doubles its argument: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">double</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">double</span> <span class="id" title="var">n&acute;</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Use induction to prove this simple fact about <span class="inlinecode"><span class="id" title="var">double</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">double_plus</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">double</span> <span class="id" title="var">n</span> = <span class="id" title="var">n</span> + <span class="id" title="var">n</span> .<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab10"></a><h4 class="section">Exercício: 1 star (destruct_induction)</h4>
 <span class="inlinecode"><span class="id" title="var">Diego</span></span> Briefly explain the difference between the tactics
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">induction</span></span>.  

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab11"></a><h1 class="section">Provas dentro de Provas</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Francisco</span></span>In Coq, as in informal mathematics, large proofs are very
    often broken into a sequence of theorems, with later proofs
    referring to earlier theorems.  Occasionally, however, a proof
    will need some miscellaneous fact that is too trivial (and of too
    little general interest) to bother giving it its own top-level
    name.  In such cases, it is convenient to be able to simply state
    and prove the needed "sub-theorem" right at the point where it is
    used.  The <span class="inlinecode"><span class="id" title="tactic">assert</span></span> tactic allows us to do this.  For example, our
    earlier proof of the <span class="inlinecode"><span class="id" title="var">mult_0_plus</span></span> theorem referred to a previous
    theorem named <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span>.  We can also use <span class="inlinecode"><span class="id" title="tactic">assert</span></span> to state and
    prove <span class="inlinecode"><span class="id" title="var">plus_O_n</span></span> in-line: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_plus&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(0 + <span class="id" title="var">n</span>) × <span class="id" title="var">m</span> = <span class="id" title="var">n</span> × <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span>: 0 + <span class="id" title="var">n</span> = <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Case</span> "Proof of assertion". <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Renan</span></span> The <span class="inlinecode"><span class="id" title="tactic">assert</span></span> tactic introduces two sub-goals.  The first is
    the assertion itself; by prefixing it with <span class="inlinecode"><span class="id" title="var">H</span>:</span> we name the
    assertion <span class="inlinecode"><span class="id" title="var">H</span></span>.  (Note that we could also name the assertion with
    <span class="inlinecode"><span class="id" title="keyword">as</span></span> just as we did above with <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">induction</span></span>, i.e.,
    <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">(0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>.  Also note that we mark the proof of
    this assertion with a <span class="inlinecode"><span class="id" title="var">Case</span></span>, both for readability and so that,
    when using Coq interactively, we can see when we're finished
    proving the assertion by observing when the <span class="inlinecode">&quot;<span class="id" title="keyword">Proof</span></span> <span class="inlinecode"><span class="id" title="var">of</span></span> <span class="inlinecode"><span class="id" title="var">assertion</span>&quot;</span>
    string disappears from the context.)  The second goal is the same
    as the one at the point where we invoke <span class="inlinecode"><span class="id" title="tactic">assert</span></span>, except that, in
    the context, we have the assumption <span class="inlinecode"><span class="id" title="var">H</span></span> that <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.  That
    is, <span class="inlinecode"><span class="id" title="tactic">assert</span></span> generates one subgoal where we must prove the
    asserted fact and a second subgoal where we can use the asserted
    fact to make progress on whatever we were trying to prove in the
    first place. 
<div class="paragraph"> </div>

 Na verdade, <span class="inlinecode"><span class="id" title="tactic">assert</span></span> será proveitoso em várias situações
 diferentes. Por exemplo, suponha que queiramos provar <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">+</span>
 <span class="inlinecode"><span class="id" title="var">q</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">p</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">q</span>)</span>. A única diferença entre os dois lados de <span class="inlinecode">=</span>
 é que os argumentos <span class="inlinecode"><span class="id" title="var">m</span></span> e <span class="inlinecode"><span class="id" title="var">n</span></span> no primeiro parênteses estão
 trocados. Desta forma, podemos usar, aparentemente, a 
 comutatividade da adição (<span class="inlinecode"><span class="id" title="var">plus_comm</span></span>) para reescrever um dos termos,
 torando ambos iguais. Porém, a tática <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> é um pouco estúpida
 com relação a <i>onde</i> ele deve aplicar a reescrita. Há três usos
 de <span class="inlinecode">+</span> aqui, e a execução de <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> irá
 afetar apenas a soma mais <i>externa</i>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_rearrange_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>) = (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">plus_comm</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Claudia</span></span> To get <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> to apply at the point where we want it, we can
    introduce a local lemma stating that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> (for
    the particular <span class="inlinecode"><span class="id" title="var">m</span></span> and <span class="inlinecode"><span class="id" title="var">n</span></span> that we are talking about here), prove
    this lemma using <span class="inlinecode"><span class="id" title="var">plus_comm</span></span>, and then use this lemma to do the
    desired rewrite. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_rearrange</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>) = (<span class="id" title="var">m</span> + <span class="id" title="var">n</span>) + (<span class="id" title="var">p</span> + <span class="id" title="var">q</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span>: <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Case</span> "Proof of assertion".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">plus_comm</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h4 class="section">Exercício: **** (mult_comm)</h4>
 <span class="inlinecode"><span class="id" title="var">Dalay</span></span>Use <span class="inlinecode"><span class="id" title="tactic">assert</span></span> to help prove this theorem.  You shouldn't need to
    use induction. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_swap</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = <span class="id" title="var">m</span> + (<span class="id" title="var">n</span> + <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Now prove commutativity of multiplication.  (You will probably
    need to define and prove a separate subsidiary theorem to be used
    in the proof of this one.)  You may find that <span class="inlinecode"><span class="id" title="var">plus_swap</span></span> comes in
    handy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_comm</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;<span class="id" title="var">m</span> × <span class="id" title="var">n</span> = <span class="id" title="var">n</span> × <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab13"></a><h4 class="section">Exercício: **, opcional (evenb_n__oddb_Sn)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Diego</span></span> Prove the following simple fact: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evenb_n__oddb_Sn</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">evenb</span> <span class="id" title="var">n</span> = <span class="id" title="var">negb</span> (<span class="id" title="var">evenb</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab14"></a><h1 class="section">Mais Exercícios</h1>

<div class="paragraph"> </div>

<a name="lab15"></a><h4 class="section">Exercício: ***, opcional (more_exercises)</h4>
 <span class="inlinecode"><span class="id" title="var">Diego</span></span> Take a piece of paper.  For each of the following theorems, first
    <i>think</i> about whether (a) it can be proved using only
    simplification and rewriting, (b) it also requires case
    analysis (<span class="inlinecode"><span class="id" title="tactic">destruct</span></span>), or (c) it also requires induction.  Write
    down your prediction.  Then fill in the proof.  (There is no need
    to turn in your piece of paper; this is just to encourage you to
    reflect before hacking!) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ble_nat_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">ble_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_nbeq_S</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">beq_nat</span> 0 (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_false_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">false</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_ble_compat_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">ble_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> = <span class="id" title="var">true</span> → <span class="id" title="var">ble_nat</span> (<span class="id" title="var">p</span> + <span class="id" title="var">n</span>) (<span class="id" title="var">p</span> + <span class="id" title="var">m</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">S_nbeq_0</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">beq_nat</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) 0 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_1_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>, 1 × <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">all3_spec</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">orb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">orb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">negb</span> <span class="id" title="var">c</span>))<br/>
&nbsp;&nbsp;= <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_plus_distr_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) × <span class="id" title="var">p</span> = (<span class="id" title="var">n</span> × <span class="id" title="var">p</span>) + (<span class="id" title="var">m</span> × <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> × (<span class="id" title="var">m</span> × <span class="id" title="var">p</span>) = (<span class="id" title="var">n</span> × <span class="id" title="var">m</span>) × <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab16"></a><h4 class="section">Exercício: **, opcional (beq_nat_refl)</h4>
 <span class="inlinecode"><span class="id" title="var">Francisco</span></span> Prove the following theorem.  Putting <span class="inlinecode"><span class="id" title="var">true</span></span> on the left-hand side
of the equality may seem odd, but this is how the theorem is stated in
the standard library, so we follow suit.  Since rewriting 
works equally well in either direction, we will have no 
problem using the theorem no matter which way we state it. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">beq_nat_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">beq_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab17"></a><h4 class="section">Exercício: **, opcional (plus_swap')</h4>
 <span class="inlinecode"><span class="id" title="var">Renan</span></span> The <span class="inlinecode"><span class="id" title="tactic">replace</span></span> tactic allows you to specify a particular subterm to
   rewrite and what you want it rewritten to.  More precisely,
   <span class="inlinecode"><span class="id" title="tactic">replace</span></span> <span class="inlinecode">(<span class="id" title="var">t</span>)</span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode">(<span class="id" title="var">u</span>)</span> replaces (all copies of) expression <span class="inlinecode"><span class="id" title="var">t</span></span> in
   the goal by expression <span class="inlinecode"><span class="id" title="var">u</span></span>, and generates <span class="inlinecode"><span class="id" title="var">t</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">u</span></span> as an additional
   subgoal. This is often useful when a plain <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> acts on the wrong
   part of the goal.  

<div class="paragraph"> </div>

   Use the <span class="inlinecode"><span class="id" title="tactic">replace</span></span> tactic to do a proof of <span class="inlinecode"><span class="id" title="var">plus_swap&acute;</span></span>, just like
   <span class="inlinecode"><span class="id" title="var">plus_swap</span></span> but without needing <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. 

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_swap&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = <span class="id" title="var">m</span> + (<span class="id" title="var">n</span> + <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab18"></a><h4 class="section">Exercício: *** (binary_commute)</h4>

<div class="paragraph"> </div>

 Relembre as funções <span class="inlinecode"><span class="id" title="var">increment</span></span> e <span class="inlinecode"><span class="id" title="var">binary</span>-<span class="id" title="var">to</span>-<span class="id" title="var">unary</span></span> que você
 escreveu para o exercício <span class="inlinecode"><span class="id" title="var">binary</span></span> no capítulo <span class="inlinecode"><span class="id" title="var">Basics</span></span>. Prove que
 estas funções comutam -- isto é, incrementar um número para binário e
 convertê-lo para unário possui o mesmo resultado que convertê-lo
 primeiro e depois incrementá-lo. Nomeie seu teorema como <span class="inlinecode"><span class="id" title="var">bin_to_nat_press_incr</span></span>.

<div class="paragraph"> </div>

  (Antes de começar a trabalhar neste exercício, por favor, copie as
  definições de sua solução para o exercício <span class="inlinecode"><span class="id" title="var">binary</span></span> daqui para que
  este arquivo esteja completo por si só. Se você deseja mudar alguma
  definição original para tornar a propriedade mais fácil de ser
  provada, sinta-se livre para realizá-la.) 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab19"></a><h4 class="section">Exercício: *****, avançado (binary_inverse)</h4>
 <span class="inlinecode"><span class="id" title="var">Cláudia</span></span> This exercise is a continuation of the previous exercise about
    binary numbers.  You will need your definitions and theorems from
    the previous exercise to complete this one.

<div class="paragraph"> </div>

    (a)<span class="inlinecode"><span class="id" title="var">Dalay</span></span>First, write a function to convert natural numbers to binary
        numbers.  Then prove that starting with any natural number,
        converting to binary, then converting back yields the same
        natural number you started with.

<div class="paragraph"> </div>

    (b)<span class="inlinecode"><span class="id" title="var">Diego</span></span>You might naturally think that we should also prove the
        opposite direction: that starting with a binary number,
        converting to a natural, and then back to binary yields the
        same number we started with.  However, it is not true!
        Explain what the problem is.

<div class="paragraph"> </div>

    (c)<span class="inlinecode"><span class="id" title="var">Francisco</span></span>Define a "direct" normalization function -- i.e., a function
        <span class="inlinecode"><span class="id" title="var">normalize</span></span> from binary numbers to binary numbers such that,
        for any binary number b, converting to a natural and then back
        to binary yields <span class="inlinecode">(<span class="id" title="var">normalize</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>.  Prove it.  (Warning: This
        part is tricky!)

<div class="paragraph"> </div>

    Again, feel free to change your earlier definitions if this helps
    here. 

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab20"></a><h1 class="section">Prova Formal e Prova Informal (Avançado)</h1>

<div class="paragraph"> </div>

 "Provas informais são algoritmos; provas formais são código." 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Renan</span></span>The question of what, exactly, constitutes a "proof" of a
    mathematical claim has challenged philosophers for millennia.  A
    rough and ready definition, though, could be this: a proof of a
    mathematical proposition <span class="inlinecode"><span class="id" title="var">P</span></span> is a written (or spoken) text that
    instills in the reader or hearer the certainty that <span class="inlinecode"><span class="id" title="var">P</span></span> is true.
    That is, a proof is an act of communication.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 Agora, os atos de comunicação podem envolver diferentes tipos de
 leitores. De um lado, o "leitor" pode ser um programa como o Coq, em
 que, no caso, a "crença" transmitida é uma simples verificação
 mecânica de que <span class="inlinecode"><span class="id" title="var">P</span></span> pode ser derivada a partir de um conjunto de
 regras lógicas formais, e a prova é uma receita que guia o programa
 em sua verificação. Estas receitas são as provas <i>formais</i>.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">Claudia</span></span>Alternatively, the reader can be a human being, in which case the
    proof will be written in English or some other natural language,
    thus necessarily <i>informal</i>.  Here, the criteria for success are
    less clearly specified.  A "good" proof is one that makes the
    reader believe <span class="inlinecode"><span class="id" title="var">P</span></span>.  But the same proof may be read by many
    different readers, some of whom may be convinced by a particular
    way of phrasing the argument, while others may not be.  One reader
    may be particularly pedantic, inexperienced, or just plain
    thick-headed; the only way to convince them will be to make the
    argument in painstaking detail.  <span class="inlinecode"><span class="id" title="var">Dalay</span></span>But another reader, more familiar
    in the area, may find all this detail so overwhelming that they
    lose the overall thread.  All they want is to be told the main
    ideas, because it is easier to fill in the details for themselves.
    Ultimately, there is no universal standard, because there is no
    single way of writing an informal proof that is guaranteed to
    convince every conceivable reader.  In practice, however,
    mathematicians have developed a rich set of conventions and idioms
    for writing about complex mathematical objects that, within a
    certain community, make communication fairly reliable.  The
    conventions of this stylized form of communication give a fairly
    clear standard for judging proofs good or bad.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">Diego</span></span>Because we are using Coq in this course, we will be working
    heavily with formal proofs.  But this doesn't mean we can ignore
    the informal ones!  Formal proofs are useful in many ways, but
    they are <i>not</i> very efficient ways of communicating ideas between
    human beings. 
<div class="paragraph"> </div>

 For example, here is a proof that addition is associative: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_assoc&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>]. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Francisco</span></span>Coq is perfectly happy with this as a proof.  For a human,
    however, it is difficult to make much sense of it.  If you're used
    to Coq you can probably step through the tactics one after the
    other in your mind and imagine the state of the context and goal
    stack at each point, but if the proof were even a little bit more
    complicated this would be next to impossible.  Instead, a
    mathematician might write it something like this: 
<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: For any <span class="inlinecode"><span class="id" title="var">n</span></span>, <span class="inlinecode"><span class="id" title="var">m</span></span> and <span class="inlinecode"><span class="id" title="var">p</span></span>,
      n + (m + p) = (n + m) + p.
    <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, suppose <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>.  We must show 
        0 + (m + p) = (0 + m) + p.  
      This follows directly from the definition of <span class="inlinecode">+</span>.

<div class="paragraph"> </div>


</li>
<li> Next, suppose <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>, where
        n' + (m + p) = (n' + m) + p.
      We must show
        (S n') + (m + p) = ((S n') + m) + p.
      By the definition of <span class="inlinecode">+</span>, this follows from
        S (n' + (m + p)) = S ((n' + m) + p),
      which is immediate from the induction hypothesis. 
</li>
</ul>

</li>
</ul>
 <i>Qed</i> 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Renan</span></span>The overall form of the proof is basically similar.  This is
    no accident: Coq has been designed so that its <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic
    generates the same sub-goals, in the same order, as the bullet
    points that a mathematician would write.  But there are
    significant differences of detail: the formal proof is much more
    explicit in some ways (e.g., the use of <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>) but much
    less explicit in others (in particular, the "proof state" at any
    given point in the Coq proof is completely implicit, whereas the
    informal proof reminds the reader several times where things
    stand). 
<div class="paragraph"> </div>

 Aqui está uma prova formal que mostra a estrutura de forma mais
 clara: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_assoc&acute;&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "n = 0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "n = S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab21"></a><h4 class="section">Exercício: **, avançado (plus_comm_informal)</h4>
 Traduza sua a sua solução de <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> para uma prova informal. 
<div class="paragraph"> </div>

 Teorema: Adição é comutativa.

<div class="paragraph"> </div>

    Proof:  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab22"></a><h4 class="section">Exercício: **, opcional (beq_nat_refl_informal)</h4>
 Escreva uma prova informal para o seguinte teorema, usando a prova
 informal para <span class="inlinecode"><span class="id" title="var">plus_assoc</span></span> como modelo. Não reescreva simplesmente as
 táticas do Coq em inglês!

<div class="paragraph"> </div>

    Theorem: <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">beq_nat</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> for any <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Proof: <font size=-2>&#9744;</font> 
</div>
<div class="code">
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>