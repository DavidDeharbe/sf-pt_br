<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Embasamento: Programação Funcional em Coq</title>
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
</head>
<h1 class="libtitle">Library Basics</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Embasamento: Programação Funcional em Coq</h1>

</div>
<div class="code">

<br/>
<span class="comment">(*<br/>
&nbsp;&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">Admitted</span></span>&nbsp;is&nbsp;Coq's&nbsp;"escape&nbsp;hatch"&nbsp;that&nbsp;says&nbsp;accept&nbsp;this&nbsp;definition<br/>
&nbsp;&nbsp;&nbsp;without&nbsp;proof.&nbsp;&nbsp;We&nbsp;use&nbsp;it&nbsp;to&nbsp;mark&nbsp;the&nbsp;'holes'&nbsp;in&nbsp;the&nbsp;development<br/>
&nbsp;&nbsp;&nbsp;that&nbsp;should&nbsp;be&nbsp;completed&nbsp;as&nbsp;part&nbsp;of&nbsp;your&nbsp;homework&nbsp;exercises.&nbsp;&nbsp;In<br/>
&nbsp;&nbsp;&nbsp;practice,&nbsp;<span class="inlinecode"><span class="id" type="var">Admitted</span></span>&nbsp;is&nbsp;useful&nbsp;when&nbsp;you're&nbsp;incrementally&nbsp;developing<br/>
&nbsp;&nbsp;&nbsp;large&nbsp;proofs.&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">admit</span> {<span class="id" type="var">T</span>: <span class="id" type="keyword">Type</span>} : <span class="id" type="var">T</span>. <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">Introdução</h1>

<div class="paragraph"> </div>

 O estilo de programação funcional aproxima a programação à matemática
simples do dia-a-dia: se um procedimento ou método não possui efeitos
colaterais, então, basicamente, tudo que você precisa entender é como
entradas são mapeadas para saídas -- isto é, você pode pensar nisto simplesmente
como um método concreto para computar uma função matemática. Esse é um dos
significados da palavra "funcional" em "programação funcional". A conexão direta
entre programas e objetos matemáticos simples autoriza tanto provas formais de
corretude quanto raciocínio informal de correção sobre o comportamento do
programa.

<div class="paragraph"> </div>

    O outro sentido no qual a programação funcional é "funcional" é a 
    ênfase que ela dá ao uso de funções (ou métodos) como valores de 
    primeira classe, como por exemplo, valores que podem ser passados 
    como argumentos para outras funções, retornados como resultados, 
    guardados em estruturas de dados, etc. O entendimento de que funções 
    podem ser tratadas como dados dessa maneira permite uma série de
    idiomas úteis e poderosos.

<div class="paragraph"> </div>

    Other common features of functional languages include <i>algebraic
    data types</i> and <i>pattern matching</i>, which make it easy to construct
    and manipulate rich data structures, and sophisticated
    <i>polymorphic type systems</i> that support abstraction and code
    reuse.  Coq shares all of these features.

<div class="paragraph"> </div>

    The first half of this chapter introduces the most essential
    elements of Coq's functional programming language.  The second
    half introduces some basic <i>tactics</i> that can be used to prove
    simple properties of Coq programs.

</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab3"></a><h1 class="section">Enumerated Types</h1>

<div class="paragraph"> </div>

 One unusual aspect of Coq is that its set of built-in
    features is <i>extremely</i> small.  For example, instead of providing
    the usual palette of atomic data types (booleans, integers,
    strings, etc.), Coq offers an extremely powerful mechanism for
    defining new data types from scratch -- so powerful that all these
    familiar types arise as instances.  

<div class="paragraph"> </div>

    Naturalmente, a distribuição Coq vem com uma extensiva biblioteca padrão,  
    fornecendo definições de booleanos, números e muitas outras estruturas de 
    dados como listas e tabelas de dispersão. Mas não há nada de mágico ou 
    primitivo sobre estas definições da biblioteca: eles foram implementados 
    com código simples de usuário. Para ilustrar isto, recapitularemos 
    explicitamente todas as definições que precisarmos neste curso, ao invés de 
    usar as definições da biblioteca.

<div class="paragraph"> </div>

    To see how this mechanism works, let's start with a very simple
    example. 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab4"></a><h2 class="section">Dias da Semana</h2>

<div class="paragraph"> </div>

 A declaração abaixo diz ao Coq que estamos definindo um novo conjunto
    de valores -- um tipo 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">day</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">monday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">tuesday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">wednesday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">thursday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">friday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">saturday</span> : <span class="id" type="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">sunday</span> : <span class="id" type="var">day</span>.<br/>

<br/>
</div>

<div class="doc">
O tipo é chamado <span class="inlinecode"><span class="id" type="var">day</span></span> e seus membros são <span class="inlinecode"><span class="id" type="var">monday</span></span>, <span class="inlinecode"><span class="id" type="var">tuesday</span></span>,
    etc. A partir da segunda linha a definição pode ser lida como
    "<span class="inlinecode"><span class="id" type="var">monday</span></span> é um <span class="inlinecode"><span class="id" type="var">day</span></span>, <span class="inlinecode"><span class="id" type="var">tuesday</span></span> é um <span class="inlinecode"><span class="id" type="var">day</span></span>", etc.

<div class="paragraph"> </div>

    Having defined <span class="inlinecode"><span class="id" type="var">day</span></span>, we can write functions that operate on
    days. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">next_weekday</span> (<span class="id" type="var">d</span>:<span class="id" type="var">day</span>) : <span class="id" type="var">day</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">d</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">monday</span>    ⇒ <span class="id" type="var">tuesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">tuesday</span>   ⇒ <span class="id" type="var">wednesday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">wednesday</span> ⇒ <span class="id" type="var">thursday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">thursday</span>  ⇒ <span class="id" type="var">friday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">friday</span>    ⇒ <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">saturday</span>  ⇒ <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">sunday</span>    ⇒ <span class="id" type="var">monday</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
One thing to note is that the argument and return types of
    this function are explicitly declared.  Like most functional
    programming languages, Coq can often figure out these types for
    itself when they are not given explicitly -- i.e., it performs
    some <i>type inference</i> -- but we'll always include them to make
    reading easier. 
<div class="paragraph"> </div>

 Having defined a function, we should check that it works on
    some examples.  There are actually three different ways to do this
    in Coq.  

<div class="paragraph"> </div>

    First, we can use the command <span class="inlinecode"><span class="id" type="keyword">Eval</span></span> <span class="inlinecode"><span class="id" type="tactic">compute</span></span> to evaluate a
    compound expression involving <span class="inlinecode"><span class="id" type="var">next_weekday</span></span>.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> (<span class="id" type="var">next_weekday</span> <span class="id" type="var">friday</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;==&gt;&nbsp;monday&nbsp;:&nbsp;day&nbsp;*)</span><br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> (<span class="id" type="var">next_weekday</span> (<span class="id" type="var">next_weekday</span> <span class="id" type="var">saturday</span>)).<br/>
&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;==&gt;&nbsp;tuesday&nbsp;:&nbsp;day&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
If you have a computer handy, this would be an excellent
    moment to fire up the Coq interpreter under your favorite IDE --
    either CoqIde or Proof General -- and try this for yourself.  Load
    this file (<span class="inlinecode"><span class="id" type="var">Basics.v</span></span>) from the book's accompanying Coq sources,
    find the above example, submit it to Coq, and observe the
    result. 
<div class="paragraph"> </div>

 A palavra-chave <span class="inlinecode"><span class="id" type="tactic">compute</span></span> informa ao Coq exatamente como avaliar as 
expressões que lhe dermos. No momento, precisamos saber apenas sobre <span class="inlinecode"><span class="id" type="tactic">compute</span></span>; 
posteriormente vermos algumas alternativas que podem ser úteis em alguns casos. 

<div class="paragraph"> </div>

 Second, we can record what we <i>expect</i> the result to be in
    the form of a Coq example: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_next_weekday</span>:<br/>
&nbsp;&nbsp;(<span class="id" type="var">next_weekday</span> (<span class="id" type="var">next_weekday</span> <span class="id" type="var">saturday</span>)) = <span class="id" type="var">tuesday</span>.<br/>

<br/>
</div>

<div class="doc">
This declaration does two things: it makes an
    assertion (that the second weekday after <span class="inlinecode"><span class="id" type="var">saturday</span></span> is <span class="inlinecode"><span class="id" type="var">tuesday</span></span>),
    and it gives the assertion a name that can be used to refer to it
    later.  Having made the assertion, we can also ask Coq to verify it,
    like this: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The details are not important for now (we'll come back to
    them in a bit), but essentially this can be read as "The assertion
    we've just made can be proved by observing that both sides of the
    equality evaluate to the same thing, after some simplification." 
<div class="paragraph"> </div>

 Por último, nós podemos pedir ao Coq para extrair da nossa 
    Definição, um programa em alguma outra linguagem de programação
    mais convencional (OCaml, Scheme, ou Haskell) com um compilador de 
    alta performance. Essa facilidade é muito interessante, posto que
    isso nos dá um modo de construir programas totalmente provados em
    liguagens mais comuns. De fato, esse é um dos usos principais para 
    o qual Coq foi criado. Nós vamos voltar para esse assunto em 
    capítulos posteriores. Mais informações podem ser encontradas no 
    livro "Coq'Art" de Bertot e Casteran, assim como no manual de 
    referência de Coq. 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab5"></a><h2 class="section">Booleans</h2>

<div class="paragraph"> </div>

 In a similar way, we can define the standard type <span class="inlinecode"><span class="id" type="var">bool</span></span> of
    booleans, with members <span class="inlinecode"><span class="id" type="var">true</span></span> and <span class="inlinecode"><span class="id" type="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">bool</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> : <span class="id" type="var">bool</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> : <span class="id" type="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Although we are rolling our own booleans here for the sake
    of building up everything from scratch, Coq does, of course,
    provide a default implementation of the booleans in its standard
    library, together with a multitude of useful functions and
    lemmas.  (Take a look at <span class="inlinecode"><span class="id" type="var">Coq.Init.Datatypes</span></span> in the Coq library
    documentation if you're interested.)  Whenever possible, we'll
    name our own definitions and theorems so that they exactly
    coincide with the ones in the standard library. 
<div class="paragraph"> </div>

 Functions over booleans can be defined in the same way as
    above: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">negb</span> (<span class="id" type="var">b</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">andb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">b2</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">orb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b1</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">true</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">false</span> ⇒ <span class="id" type="var">b2</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The last two illustrate the syntax for multi-argument
    function definitions. 
<div class="paragraph"> </div>

 The following four "unit tests" constitute a complete
    specification -- a truth table -- for the <span class="inlinecode"><span class="id" type="var">orb</span></span> function: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb1</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">true</span>  <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb2</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">false</span> <span class="id" type="var">false</span>) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb3</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>)  = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_orb4</span>:  (<span class="id" type="var">orb</span> <span class="id" type="var">true</span>  <span class="id" type="var">true</span>)  = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
(Note that we've dropped the <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> in the proofs.  It's not
    actually needed because <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> automatically performs
    simplification.) 
<div class="paragraph"> </div>

 <i>Uma observação sobre anotações: Em arquivos .v, utilizamos colchetes 
para delimitar fragmentos de código Coq nos comentários. O objetivo desta 
convenção, também usada pela ferramenta de documentação <span class="inlinecode"><span class="id" type="var">coqdoc</span></span>, é manter 
estes fragmentos visualmente diferentes do texto ao redor: na versão html dos 
arquivos, estas partes do texto aparecem com uma <span class="inlinecode"><span class="id" type="var">fonte</span></span> <span class="inlinecode"><span class="id" type="var">diferente</span></span>. 
<div class="paragraph"> </div>

 The values <span class="inlinecode"><span class="id" type="var">Admitted</span></span> and <span class="inlinecode"><span class="id" type="var">admit</span></span> can be used to fill
    a hole in an incomplete definition or proof.  We'll use them in the
    following exercises.  In general, your job in the exercises is 
    to replace <span class="inlinecode"><span class="id" type="var">admit</span></span> or <span class="inlinecode"><span class="id" type="var">Admitted</span></span> with real definitions or proofs. 
<div class="paragraph"> </div>

<a name="lab6"></a><h4 class="section">Exercício: 1 estrela (nandb)</h4>
 Complete a definição das seguintes funções, depois, certifique que
    as asserções <span class="inlinecode"><span class="id" type="keyword">Example</span></span> abaixo podem ser verificadas pelo Coq.  
<div class="paragraph"> </div>

 This function should return <span class="inlinecode"><span class="id" type="var">true</span></span> if either or both of
    its inputs are <span class="inlinecode"><span class="id" type="var">false</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">nandb</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
</div>

<div class="doc">
Remove "<span class="inlinecode"><span class="id" type="var">Admitted</span>.</span>" and fill in each proof with 
    "<span class="inlinecode"><span class="id" type="keyword">Proof</span>.</span> <span class="inlinecode"><span class="id" type="tactic">reflexivity</span>.</span> <span class="inlinecode"><span class="id" type="keyword">Qed</span>.</span>" 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb1</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb2</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">false</span> <span class="id" type="var">false</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb3</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_nandb4</span>:               (<span class="id" type="var">nandb</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab7"></a><h4 class="section">Exercise: 1 star (andb3)</h4>
 Do the same for the <span class="inlinecode"><span class="id" type="var">andb3</span></span> function below. This function should
    return <span class="inlinecode"><span class="id" type="var">true</span></span> when all of its inputs are <span class="inlinecode"><span class="id" type="var">true</span></span>, and <span class="inlinecode"><span class="id" type="var">false</span></span>
    otherwise. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">andb3</span> (<span class="id" type="var">b1</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b2</span>:<span class="id" type="var">bool</span>) (<span class="id" type="var">b3</span>:<span class="id" type="var">bool</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb31</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span>) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb32</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb33</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span> <span class="id" type="var">true</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_andb34</span>:                 (<span class="id" type="var">andb3</span> <span class="id" type="var">true</span> <span class="id" type="var">true</span> <span class="id" type="var">false</span>) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab8"></a><h2 class="section">Function Types</h2>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="keyword">Check</span></span> command causes Coq to print the type of an
    expression.  For example, the type of <span class="inlinecode"><span class="id" type="var">negb</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> is <span class="inlinecode"><span class="id" type="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;true&nbsp;:&nbsp;bool&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">negb</span> <span class="id" type="var">true</span>).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;negb&nbsp;true&nbsp;:&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Functions like <span class="inlinecode"><span class="id" type="var">negb</span></span> itself are also data values, just like
    <span class="inlinecode"><span class="id" type="var">true</span></span> and <span class="inlinecode"><span class="id" type="var">false</span></span>.  Their types are called <i>function types</i>, and
    they are written with arrows. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">negb</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;negb&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;bool&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
The type of <span class="inlinecode"><span class="id" type="var">negb</span></span>, written <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> and pronounced
    "<span class="inlinecode"><span class="id" type="var">bool</span></span> arrow <span class="inlinecode"><span class="id" type="var">bool</span></span>," can be read, "Given an input of type
    <span class="inlinecode"><span class="id" type="var">bool</span></span>, this function produces an output of type <span class="inlinecode"><span class="id" type="var">bool</span></span>."
    Similarly, the type of <span class="inlinecode"><span class="id" type="var">andb</span></span>, written <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">bool</span></span>, can
    be read, "Given two inputs, both of type <span class="inlinecode"><span class="id" type="var">bool</span></span>, this function
    produces an output of type <span class="inlinecode"><span class="id" type="var">bool</span></span>." 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab9"></a><h2 class="section">Numbers</h2>

<div class="paragraph"> </div>

 <i>Digressão técnica</i>: O Coq fornece um <i>sistema modular</i> bastante 
sofisticado para auxiliar na organização de desenvolvimentos robustos. Neste 
curso não precisaremos da maioria de suas funcionalidades, mas uma é bastante 
útil: se inserimos uma coleção de declarações entre os marcadores <span class="inlinecode"><span class="id" type="keyword">Module</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> e 
<span class="inlinecode"><span class="id" type="keyword">End</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>, então, no restante do arquivo após o <span class="inlinecode"><span class="id" type="keyword">End</span></span>, estas definições serão 
referenciadas através de nomes como <span class="inlinecode"><span class="id" type="var">X.foo</span></span> no lugar de <span class="inlinecode"><span class="id" type="var">foo</span></span>. Aqui, usaremos 
esta funcionalidade para introduzir a definição do tipo <span class="inlinecode"><span class="id" type="var">nat</span></span> em um módulo 
interno, para que a definição presente na biblioteca padrão não seja omitida. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">Playground1</span>.<br/>

<br/>
</div>

<div class="doc">
Os tipos que definimos até o momento são exemplos de “tipos enumerados”: suas definições enumeram explicitamente um conjunto finito de elementos. Uma forma mais interessante de definir um tipo é através de uma coleção de "regras indutivas" descrevendo seus elementos. Por exemplo, podemos definir os números naturais desta forma: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">nat</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> : <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> : <span class="id" type="var">nat</span> → <span class="id" type="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
As cláusulas desta definição podem ser lidas como: 
<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">O</span></span> is a natural number (note that this is the letter "<span class="inlinecode"><span class="id" type="var">O</span></span>," not
        the numeral "<span class="inlinecode">0</span>").

</li>
<li> <span class="inlinecode"><span class="id" type="var">S</span></span> is a "constructor" that takes a natural number and yields
        another one -- that is, if <span class="inlinecode"><span class="id" type="var">n</span></span> is a natural number, then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
        is too.

</li>
</ul>

<div class="paragraph"> </div>

    Vamos olhar isso com um pouco mais de detalhamento.

<div class="paragraph"> </div>

    Every inductively defined set (<span class="inlinecode"><span class="id" type="var">day</span></span>, <span class="inlinecode"><span class="id" type="var">nat</span></span>, <span class="inlinecode"><span class="id" type="var">bool</span></span>, etc.) is
    actually a set of <i>expressions</i>.  The definition of <span class="inlinecode"><span class="id" type="var">nat</span></span> says how
    expressions in the set <span class="inlinecode"><span class="id" type="var">nat</span></span> can be constructed:

<div class="paragraph"> </div>

<ul class="doclist">
<li> the expression <span class="inlinecode"><span class="id" type="var">O</span></span> belongs to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>; 

</li>
<li> if <span class="inlinecode"><span class="id" type="var">n</span></span> is an expression belonging to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>, then <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>
      is also an expression belonging to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>; and

</li>
<li> expressions formed in these two ways are the only ones belonging
      to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>.

</li>
</ul>
    The same rules apply for our definitions of <span class="inlinecode"><span class="id" type="var">day</span></span> and <span class="inlinecode"><span class="id" type="var">bool</span></span>. The
    annotations we used for their constructors are analogous to the
    one for the <span class="inlinecode"><span class="id" type="var">O</span></span> constructor, and indicate that each of those
    constructors doesn't take any arguments. 
<div class="paragraph"> </div>

 These three conditions are the precise force of the
    <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> declaration.  They imply that the expression <span class="inlinecode"><span class="id" type="var">O</span></span>, the
    expression <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span>, the expression <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span>, the expression
    <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span>, and so on all belong to the set <span class="inlinecode"><span class="id" type="var">nat</span></span>, while other
    expressions like <span class="inlinecode"><span class="id" type="var">true</span></span>, <span class="inlinecode"><span class="id" type="var">andb</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> <span class="inlinecode"><span class="id" type="var">false</span></span>, and <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">false</span>)</span> do
    not.

<div class="paragraph"> </div>

	Nós podemos escrever funções simples que realiza combinação de padrões em 
	números naturais assim como fizemos acima -- por exemplo, a função 
	predecessor: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">pred</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
O segundo ramo pode ser lido assim:"se <span class="inlinecode"><span class="id" type="var">n</span></span> possui a forma <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> para algum 
<span class="inlinecode"><span class="id" type="var">n'</span></span>, então retorne <span class="inlinecode"><span class="id" type="var">n'</span></span>." 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">Playground1</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">minustwo</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) ⇒ <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Como os números naturais são uma forma de informação tão difundida, Coq 
provê um pouquinho de mágica construída internamente para interpretá-los e 
imprimí-los: algarismos árabes comuns podem ser usados como alternativa para a 
notação "unária" definida pelos construtores <span class="inlinecode"><span class="id" type="var">S</span></span> e <span class="inlinecode"><span class="id" type="var">O</span></span>. Por padrão, Coq imprime 
números na forma árabe: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)))).<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> (<span class="id" type="var">minustwo</span> 4).<br/>

<br/>
</div>

<div class="doc">
O construtor <span class="inlinecode"><span class="id" type="var">S</span></span> possui o tipo <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>, assim como as funções 
<span class="inlinecode"><span class="id" type="var">minustwo</span></span> e <span class="inlinecode"><span class="id" type="var">pred</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">S</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">pred</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">minustwo</span>.<br/>

<br/>
</div>

<div class="doc">
Estas são todas as coisas que podem ser aplicadas a um número para obter 
outro número. Porém, existe uma diferença fundamental: funções como <span class="inlinecode"><span class="id" type="var">pred</span></span> e 
<span class="inlinecode"><span class="id" type="var">minustwo</span></span> vêm com <i>regras computacionais</i> -- por exemplo, a definição de 
<span class="inlinecode"><span class="id" type="var">pred</span></span> afirma que <span class="inlinecode"><span class="id" type="var">pred</span></span> <span class="inlinecode">2</span> pode ser simplificado para <span class="inlinecode">1</span> -- enquanto que a 
definição de <span class="inlinecode"><span class="id" type="var">S</span></span> não possui nenhum comportamento incorporado. Embora o último 
seja uma função no sentido de que pode ser aplicado a um argumento, ele 
realmente não <i>faz</i> nada!  
<div class="paragraph"> </div>

 For most function definitions over numbers, pure pattern
    matching is not enough: we also need recursion.  For example, to
    check that a number <span class="inlinecode"><span class="id" type="var">n</span></span> is even, we may need to recursively check
    whether <span class="inlinecode"><span class="id" type="var">n</span>-2</span> is even.  To write such functions, we use the
    keyword <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">evenb</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>        ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">O</span>      ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n'</span>) ⇒ <span class="id" type="var">evenb</span> <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can define <span class="inlinecode"><span class="id" type="var">oddb</span></span> by a similar <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> declaration, but here
    is a simpler definition that will be a bit easier to work with: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">oddb</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span>   :=   <span class="id" type="var">negb</span> (<span class="id" type="var">evenb</span> <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_oddb1</span>:    (<span class="id" type="var">oddb</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>)) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_oddb2</span>:    (<span class="id" type="var">oddb</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))))) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Naturally, we can also define multi-argument functions by
    recursion.  (Once again, we use a module to avoid polluting the
    namespace.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">Playground2</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">plus</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">S</span> (<span class="id" type="var">plus</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Adding three to two now gives us five, as we'd expect. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> (<span class="id" type="var">plus</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))) (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">O</span>))).<br/>

<br/>
</div>

<div class="doc">
The simplification that Coq performs to reach this conclusion can
    be visualized as follows: 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;&nbsp;<span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)))</span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span>&nbsp;&nbsp;&nbsp;&nbsp;<br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">plus</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))</span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)))</span>&nbsp;by&nbsp;the&nbsp;second&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">plus</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)</span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))))</span>&nbsp;by&nbsp;the&nbsp;second&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">O</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>)))))</span>&nbsp;by&nbsp;the&nbsp;second&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
==&gt;&nbsp;<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">O</span>))))</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;the&nbsp;first&nbsp;clause&nbsp;of&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="keyword">match</span></span><br/>
*)</span><br/>

<br/>
</div>

<div class="doc">
As a notational convenience, if two or more arguments have
    the same type, they can be written together.  In the following
    definition, <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> means just the same as if we had written
    <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> <span class="inlinecode">(<span class="id" type="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">mult</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">plus</span> <span class="id" type="var">m</span> (<span class="id" type="var">mult</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_mult1</span>: (<span class="id" type="var">mult</span> 3 3) = 9.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
You can match two expressions at once by putting a comma
    between them: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">minus</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span>, <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>   , <span class="id" type="var">_</span>    ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">_</span> , <span class="id" type="var">O</span>    ⇒ <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span>, <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">minus</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The _ in the first line is a <i>wildcard pattern</i>.  Writing _ in a
    pattern is the same as writing some variable that doesn't get used
    on the right-hand side.  This avoids the need to invent a bogus
    variable name. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">Playground2</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">exp</span> (<span class="id" type="var">base</span> <span class="id" type="var">power</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">power</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">S</span> <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">p</span> ⇒ <span class="id" type="var">mult</span> <span class="id" type="var">base</span> (<span class="id" type="var">exp</span> <span class="id" type="var">base</span> <span class="id" type="var">p</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab10"></a><h4 class="section">Exercise: 1 star (factorial)</h4>
 Recall the standard factorial function:
<pre>
    factorial(0)  =  1 
    factorial(n)  =  n * factorial(n-1)     (if n&gt;0)
</pre>
    Translate this into Coq. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">factorial</span> (<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> := <br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_factorial1</span>:          (<span class="id" type="var">factorial</span> 3) = 6.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_factorial2</span>:          (<span class="id" type="var">factorial</span> 5) = (<span class="id" type="var">mult</span> 10 12).<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Nós podemos tornar a leitura e a escrita de expressões numéricas
    mais fáceis ao introduzir "notações" para adição, multiplicação 
    e subtração. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> "x + y" := (<span class="id" type="var">plus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 50, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> "x - y" := (<span class="id" type="var">minus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 50, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> "x * y" := (<span class="id" type="var">mult</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> ((0 + 1) + 1).<br/>

<br/>
</div>

<div class="doc">
(As anotações <span class="inlinecode"><span class="id" type="keyword">level</span></span>, <span class="inlinecode"><span class="id" type="keyword">associativity</span></span>, e <span class="inlinecode"><span class="id" type="var">nat_scope</span></span> controlam
    como essas notações são tratadas pelo analisador do Coq. Os 
    detalhes não são importantes, mas leitores interessados podem
    se dirigir à subseção "Mais em Notações", na seção de "Material 
    Avançado", no final desse capítulo.) 
<div class="paragraph"> </div>

 Note that these do not change the definitions we've already
    made: they are simply instructions to the Coq parser to accept <span class="inlinecode"><span class="id" type="var">x</span></span>
    <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">y</span></span> in place of <span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> and, conversely, to the Coq
    pretty-printer to display <span class="inlinecode"><span class="id" type="var">plus</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">y</span></span> as <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">y</span></span>. 
<div class="paragraph"> </div>

 When we say that Coq comes with nothing built-in, we really
    mean it: even equality testing for numbers is a user-defined
    operation!  The <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> function tests <span class="inlinecode"><span class="id" type="var">nat</span></span>ural numbers for <span class="inlinecode"><span class="id" type="var">eq</span></span>uality,
    yielding a <span class="inlinecode"><span class="id" type="var">b</span></span>oolean.  Note the use of nested <span class="inlinecode"><span class="id" type="keyword">match</span></span>es (we could
    also have used a simultaneous match, as we did in <span class="inlinecode"><span class="id" type="var">minus</span></span>.)  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">beq_nat</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, the <span class="inlinecode"><span class="id" type="var">ble_nat</span></span> function tests <span class="inlinecode"><span class="id" type="var">nat</span></span>ural numbers for
    <span class="inlinecode"><span class="id" type="var">l</span></span>ess-or-<span class="inlinecode"><span class="id" type="var">e</span></span>qual, yielding a <span class="inlinecode"><span class="id" type="var">b</span></span>oolean. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">ble_nat</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">ble_nat</span> <span class="id" type="var">n'</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ble_nat1</span>:             (<span class="id" type="var">ble_nat</span> 2 2) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ble_nat2</span>:             (<span class="id" type="var">ble_nat</span> 2 4) = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_ble_nat3</span>:             (<span class="id" type="var">ble_nat</span> 4 2) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab11"></a><h4 class="section">Exercise: 2 stars (blt_nat)</h4>
 The <span class="inlinecode"><span class="id" type="var">blt_nat</span></span> function tests <span class="inlinecode"><span class="id" type="var">nat</span></span>ural numbers for <span class="inlinecode"><span class="id" type="var">l</span></span>ess-<span class="inlinecode"><span class="id" type="var">t</span></span>han,
    yielding a <span class="inlinecode"><span class="id" type="var">b</span></span>oolean.  Instead of making up a new <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> for
    this one, define it in terms of a previously defined function. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">blt_nat</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">admit</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_blt_nat1</span>:             (<span class="id" type="var">blt_nat</span> 2 2) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_blt_nat2</span>:             (<span class="id" type="var">blt_nat</span> 2 4) = <span class="id" type="var">true</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">Example</span> <span class="id" type="var">test_blt_nat3</span>:             (<span class="id" type="var">blt_nat</span> 4 2) = <span class="id" type="var">false</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab12"></a><h1 class="section">Proof by Simplification</h1>

<div class="paragraph"> </div>

 Now that we've defined a few datatypes and functions, let's
    turn to the question of how to state and prove properties of their
    behavior.  Actually, in a sense, we've already started doing this:
    each <span class="inlinecode"><span class="id" type="keyword">Example</span></span> in the previous sections makes a precise claim
    about the behavior of some function on some particular inputs.
    The proofs of these claims were always the same: use <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 
    to check that both sides of the <span class="inlinecode">=</span> simplify to identical values. 

<div class="paragraph"> </div>

	(A propósito, posteriormente será útil saber que <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> na verdade 
	perfaz mais simplificação do que <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> -- por exemplo, ele tenta 
	"desdobrar" termos definidos, substituindo-os pelos seus lados direitos. A 
	razão para esta diferença é que, quando a aplicação da reflexividade é bem 
	sucedida, todo o objetivo é finalizado e não precisaremos visualizar as 
	expressões que foram expandidas por <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>. Em contrapartida, 
	<span class="inlinecode"><span class="id" type="tactic">simpl</span></span> é usado em situações onde devemos ler e entender o objetivo, então 
	não queremos que definições sejam expandidas sem nosso conhecimento.) 

<div class="paragraph"> </div>

    The same sort of "proof by simplification" can be used to prove
    more interesting properties as well.  For example, the fact that
    <span class="inlinecode">0</span> is a "neutral element" for <span class="inlinecode">+</span> on the left can be proved
    just by observing that <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> reduces to <span class="inlinecode"><span class="id" type="var">n</span></span> no matter what
    <span class="inlinecode"><span class="id" type="var">n</span></span> is, a fact that can be read directly off the definition of <span class="inlinecode"><span class="id" type="var">plus</span></span>.
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_O_n</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, 0 + <span class="id" type="var">n</span> = <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
(<i>Note</i>: You may notice that the above statement looks
    different in the original source file and the final html output. In Coq
    files, we write the <span class="inlinecode"><span class="id" type="keyword">∀</span></span> universal quantifier using the
    "<i>forall</i>" reserved identifier. This gets printed as an
    upside-down "A", the familiar symbol used in logic.)  
<div class="paragraph"> </div>

 As formas desse teorema e da prova são quase exatamente as mesmas
    que no exemplo acima; Existem somente algumas diferenças.

<div class="paragraph"> </div>

    First, we've used the keyword <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> instead of
    <span class="inlinecode"><span class="id" type="keyword">Example</span></span>.  Indeed, the difference is purely a matter of
    style; the keywords <span class="inlinecode"><span class="id" type="keyword">Example</span></span> and <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> (and a few others,
    including <span class="inlinecode"><span class="id" type="keyword">Lemma</span></span>, <span class="inlinecode"><span class="id" type="keyword">Fact</span></span>, and <span class="inlinecode"><span class="id" type="keyword">Remark</span></span>) mean exactly the same
    thing to Coq.

<div class="paragraph"> </div>

    Secondly, we've added the quantifier <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><span class="id" type="var">n</span>:<span class="id" type="var">nat</span></span>, so that our
    theorem talks about <i>all</i> natural numbers <span class="inlinecode"><span class="id" type="var">n</span></span>.  In order to prove
    theorems of this form, we need to to be able to reason by
    <i>assuming</i> the existence of an arbitrary natural number <span class="inlinecode"><span class="id" type="var">n</span></span>.  This
    is achieved in the proof by <span class="inlinecode"><span class="id" type="tactic">intros</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>, which moves the quantifier
    from the goal to a "context" of current assumptions. In effect, we
    start the proof by saying "OK, suppose <span class="inlinecode"><span class="id" type="var">n</span></span> is some arbitrary number."

<div class="paragraph"> </div>

    The keywords <span class="inlinecode"><span class="id" type="tactic">intros</span></span>, <span class="inlinecode"><span class="id" type="tactic">simpl</span></span>, and <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> are examples of
    <i>tactics</i>.  A tactic is a command that is used between <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> and
    <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> to tell Coq how it should check the correctness of some
    claim we are making.  We will see several more tactics in the rest
    of this lecture, and yet more in future lectures. 
<div class="paragraph"> </div>

 Poderíamos provar um teorema similar sobre <span class="inlinecode"><span class="id" type="var">plus</span></span> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_n_O</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <span class="id" type="var">n</span> + 0 = <span class="id" type="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
Porém, diferentemente da prova anterior, <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> não faz nada neste caso 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;Doesn't&nbsp;do&nbsp;anything!&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
(Você consegue explicar por que isto acontece? Percorra ambas as provas com Coq e perceba como o objetivo e o contexto mudam.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_l</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, 1 + <span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_0_l</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>:<span class="id" type="var">nat</span>, 0 × <span class="id" type="var">n</span> = 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="comment">(**O&nbsp;sufixo&nbsp;<span class="inlinecode"><span class="id" type="var">_l</span></span>&nbsp;nos&nbsp;nomes&nbsp;destes&nbsp;teoremas&nbsp;é&nbsp;pronunciado&nbsp;"à&nbsp;esquerda."&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab13"></a><h1 class="section">Proof by Rewriting</h1>

<div class="paragraph"> </div>

 Here is a slightly more interesting theorem: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_id_example</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>:<span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> → <br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> + <span class="id" type="var">n</span> = <span class="id" type="var">m</span> + <span class="id" type="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Instead of making a completely universal claim about all numbers
    <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>, this theorem talks about a more specialized property
    that only holds when <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>.  The arrow symbol is pronounced
    "implies."

<div class="paragraph"> </div>

    As before, we need to be able to reason by assuming the existence
    of some numbers <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span>.  We also need to assume the hypothesis
    <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>. The <span class="inlinecode"><span class="id" type="tactic">intros</span></span> tactic will serve to move all three of these
    from the goal into assumptions in the current context. 

<div class="paragraph"> </div>

    Since <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span> are arbitrary numbers, we can't just use
    simplification to prove this theorem.  Instead, we prove it by
    observing that, if we are assuming <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>, then we can replace
    <span class="inlinecode"><span class="id" type="var">n</span></span> with <span class="inlinecode"><span class="id" type="var">m</span></span> in the goal statement and obtain an equality with the
    same expression on both sides.  The tactic that tells Coq to
    perform this replacement is called <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="comment">(*&nbsp;move&nbsp;both&nbsp;quantifiers&nbsp;into&nbsp;the&nbsp;context&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="comment">(*&nbsp;move&nbsp;the&nbsp;hypothesis&nbsp;into&nbsp;the&nbsp;context&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> → <span class="id" type="var">H</span>. <span class="comment">(*&nbsp;Rewrite&nbsp;the&nbsp;goal&nbsp;using&nbsp;the&nbsp;hypothesis&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The first line of the proof moves the universally quantified
    variables <span class="inlinecode"><span class="id" type="var">n</span></span> and <span class="inlinecode"><span class="id" type="var">m</span></span> into the context.  The second moves the
    hypothesis <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> into the context and gives it the (arbitrary)
    name <span class="inlinecode"><span class="id" type="var">H</span></span>.  The third tells Coq to rewrite the current goal (<span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span>
    <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">m</span></span>) by replacing the left side of the equality hypothesis
    <span class="inlinecode"><span class="id" type="var">H</span></span> with the right side.

<div class="paragraph"> </div>

    (The arrow symbol in the <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> has nothing to do with
    implication: it tells Coq to apply the rewrite from left to right.
    To rewrite from right to left, you can use <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span>.  Try
    making this change in the above proof and see what difference it
    makes in Coq's behavior.) 
<div class="paragraph"> </div>

<a name="lab14"></a><h4 class="section">Exercise: 1 star (plus_id_exercise)</h4>
 Remove "<span class="inlinecode"><span class="id" type="var">Admitted</span>.</span>" and fill in the proof. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_id_exercise</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">n</span> = <span class="id" type="var">m</span> → <span class="id" type="var">m</span> = <span class="id" type="var">o</span> → <span class="id" type="var">n</span> + <span class="id" type="var">m</span> = <span class="id" type="var">m</span> + <span class="id" type="var">o</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Como vimos nos exemplos anteriores, o comando <span class="inlinecode"><span class="id" type="var">Admitted</span></span> informa a Coq que 
queremos pular a tentativa de prova do teorema e simplesmente aceitar a 
declaração dada. Isto pode ser útil no desenvolvimento de provas mais longas, 
uma vez que podemos determinar fatos subsidiários que acreditamos serem 
importantes na criação de argumentos maiores. Use <span class="inlinecode"><span class="id" type="var">Admitted</span></span> para aceitar 
estes teoremas na fé do momento, e continuar pensando no argumento maior 
até termos certeza de que faz sentido; e então, poderemos voltar e concluir 
as provas incompletas. Porém tenha cuidado: Toda vez que você usa <span class="inlinecode"></span>
<span class="inlinecode"><span class="id" type="var">Admitted</span></span> (ou <span class="inlinecode"><span class="id" type="var">admit</span></span>) você está deixando uma porta aberta para que um 
disparate total	entre no mundo formal, rigoroso, verificado e agradável 
do Coq. 
<div class="paragraph"> </div>

 We can also use the <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> tactic with a previously proved
    theorem instead of a hypothesis from the context. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_0_plus</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;(0 + <span class="id" type="var">n</span>) × <span class="id" type="var">m</span> = <span class="id" type="var">n</span> × <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> → <span class="id" type="var">plus_O_n</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h4 class="section">Exercise: 2 stars (mult_S_1)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">mult_S_1</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span> → <br/>
&nbsp;&nbsp;<span class="id" type="var">m</span> × (1 + <span class="id" type="var">n</span>) = <span class="id" type="var">m</span> × <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab16"></a><h1 class="section">Proof by Case Analysis</h1>

<div class="paragraph"> </div>

 Of course, not everything can be proved by simple
    calculation: In general, unknown, hypothetical values (arbitrary
    numbers, booleans, lists, etc.) can block the calculation.  
    For example, if we try to prove the following fact using the 
    <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> tactic as above, we get stuck. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_neq_0_firsttry</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> + 1) 0 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="comment">(*&nbsp;does&nbsp;nothing!&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
The reason for this is that the definitions of both
    <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> and <span class="inlinecode">+</span> begin by performing a <span class="inlinecode"><span class="id" type="keyword">match</span></span> on their first
    argument.  But here, the first argument to <span class="inlinecode">+</span> is the unknown
    number <span class="inlinecode"><span class="id" type="var">n</span></span> and the argument to <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> is the compound
    expression <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>; neither can be simplified.

<div class="paragraph"> </div>

    What we need is to be able to consider the possible forms of <span class="inlinecode"><span class="id" type="var">n</span></span>
    separately.  If <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode"><span class="id" type="var">O</span></span>, then we can calculate the final result
    of <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> and check that it is, indeed, <span class="inlinecode"><span class="id" type="var">false</span></span>.
    And if <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> for some <span class="inlinecode"><span class="id" type="var">n'</span></span>, then, although we don't know
    exactly what number <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> yields, we can calculate that, at
    least, it will begin with one <span class="inlinecode"><span class="id" type="var">S</span></span>, and this is enough to calculate
    that, again, <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode">(<span class="id" type="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> will yield <span class="inlinecode"><span class="id" type="var">false</span></span>.

<div class="paragraph"> </div>

    The tactic that tells Coq to consider, separately, the cases where
    <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">O</span></span> and where <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> is called <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">plus_1_neq_0</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> (<span class="id" type="var">n</span> + 1) 0 = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> generates <i>two</i> subgoals, which we must then
    prove, separately, in order to get Coq to accept the theorem as
    proved.  (No special command is needed for moving from one subgoal
    to the other.  When the first subgoal has been proved, it just
    disappears and we are left with the other "in focus.")  In this
    proof, each of the subgoals is easily proved by a single use of
    <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>.

<div class="paragraph"> </div>

    The annotation "<span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" type="var">n'</span>]</span>" is called an <i>intro pattern</i>.  It
    tells Coq what variable names to introduce in each subgoal.  In
    general, what goes between the square brackets is a <i>list</i> of
    lists of names, separated by <span class="inlinecode">|</span>.  Here, the first component is
    empty, since the <span class="inlinecode"><span class="id" type="var">O</span></span> constructor is nullary (it doesn't carry any
    data).  The second component gives a single name, <span class="inlinecode"><span class="id" type="var">n'</span></span>, since <span class="inlinecode"><span class="id" type="var">S</span></span>
    is a unary constructor.

<div class="paragraph"> </div>

A tática <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> pode ser usada com qualquer tipo de dado definido 
indutivamente. Por exemplo, nós podemos usá-lo aqui para provar que a 
negação booleana é involutiva – isto é, que a negação é a sua própria 
inversa. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">negb_involutive</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">negb</span> (<span class="id" type="var">negb</span> <span class="id" type="var">b</span>) = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note que <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> aqui não possui nenhuma cláusula <span class="inlinecode"><span class="id" type="keyword">as</span></span> pois nenhum dos 
subcasos de <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> precisa ser vinculado a nenhuma das variáveis. Por isso, 
não há necessidade de especificar nenhum nome (Poderíamos ter escrito também 
<span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[|]</span>, ou <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode">[]</span>). De fato, podemos omitir a cláusula <span class="inlinecode"><span class="id" type="keyword">as</span></span> de qualquer 
<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> e Coq irá preencher automaticamente os nomes de variáveis. Embora 
seja conveniente, isto é indiscutivelmente um estilo ruim, uma vez que o Coq 
pode fazer escolhas confusas de nomes quando lhe é deixada esta decisão. 
<div class="paragraph"> </div>

<a name="lab17"></a><h4 class="section">Exercise: 1 star (zero_nbeq_plus_1)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">zero_nbeq_plus_1</span> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> 0 (<span class="id" type="var">n</span> + 1) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab18"></a><h1 class="section">More Exercises</h1>

<div class="paragraph"> </div>

<a name="lab19"></a><h4 class="section">Exercise: 2 stars (boolean_functions)</h4>
 Use the tactics you have learned so far to prove the following 
    theorem about boolean functions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">identity_fn_applied_twice</span> : <br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">f</span> : <span class="id" type="var">bool</span> → <span class="id" type="var">bool</span>), <br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> (<span class="id" type="var">x</span> : <span class="id" type="var">bool</span>), <span class="id" type="var">f</span> <span class="id" type="var">x</span> = <span class="id" type="var">x</span>) →<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">b</span> : <span class="id" type="var">bool</span>), <span class="id" type="var">f</span> (<span class="id" type="var">f</span> <span class="id" type="var">b</span>) = <span class="id" type="var">b</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Now state and prove a theorem <span class="inlinecode"><span class="id" type="var">negation_fn_applied_twice</span></span> similar
    to the previous one but where the second hypothesis says that the
    function <span class="inlinecode"><span class="id" type="var">f</span></span> has the property that <span class="inlinecode"><span class="id" type="var">f</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">negb</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>.
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab20"></a><h4 class="section">Exercise: 2 stars (andb_eq_orb)</h4>
 Prove the following theorem.  (You may want to first prove a
    subsidiary lemma or two. Alternatively, remember that you do
    not have to introduce all hypotheses at the same time.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_eq_orb</span> : <br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">b</span> <span class="id" type="var">c</span> : <span class="id" type="var">bool</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">orb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) →<br/>
&nbsp;&nbsp;<span class="id" type="var">b</span> = <span class="id" type="var">c</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab21"></a><h4 class="section">Exercise: 3 stars (binary)</h4>
 Consider a different, more efficient representation of natural
    numbers using a binary rather than unary system.  That is, instead
    of saying that each natural number is either zero or the successor
    of a natural number, we can say that each binary number is either

<div class="paragraph"> </div>

<ul class="doclist">
<li> zero,

</li>
<li> twice a binary number, or

</li>
<li> one more than twice a binary number.

<div class="paragraph"> </div>

	(a) Primeiro, escreva uma definição indutiva para o tipo <span class="inlinecode"><span class="id" type="var">bin</span></span> que corresponda a esta descrição de números binários.

</li>
</ul>

<div class="paragraph"> </div>

    (Hint: Recall that the definition of <span class="inlinecode"><span class="id" type="var">nat</span></span> from class,
    Inductive nat : Type :=
      | O : nat
      | S : nat -&gt; nat.
    says nothing about what <span class="inlinecode"><span class="id" type="var">O</span></span> and <span class="inlinecode"><span class="id" type="var">S</span></span> "mean."  It just says "<span class="inlinecode"><span class="id" type="var">O</span></span> is
    in the set called <span class="inlinecode"><span class="id" type="var">nat</span></span>, and if <span class="inlinecode"><span class="id" type="var">n</span></span> is in the set then so is <span class="inlinecode"><span class="id" type="var">S</span></span>
    <span class="inlinecode"><span class="id" type="var">n</span></span>."  The interpretation of <span class="inlinecode"><span class="id" type="var">O</span></span> as zero and <span class="inlinecode"><span class="id" type="var">S</span></span> as successor/plus
    one comes from the way that we <i>use</i> <span class="inlinecode"><span class="id" type="var">nat</span></span> values, by writing
    functions to do things with them, proving things about them, and
    so on.  Your definition of <span class="inlinecode"><span class="id" type="var">bin</span></span> should be correspondingly simple;
    it is the functions you will write next that will give it
    mathematical meaning.)

<div class="paragraph"> </div>

    (b) Next, write an increment function <span class="inlinecode"><span class="id" type="var">incr</span></span> for binary numbers, 
        and a function <span class="inlinecode"><span class="id" type="var">bin_to_nat</span></span> to convert binary numbers to unary numbers.

<div class="paragraph"> </div>

    (c) Write five unit tests <span class="inlinecode"><span class="id" type="var">test_bin_incr1</span></span>, <span class="inlinecode"><span class="id" type="var">test_bin_incr2</span></span>, etc.
        for your increment and binary-to-unary functions. Notice that 
        incrementing a binary number and then converting it to unary 
        should yield the same result as first converting it to unary and 
        then incrementing. 

</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="comment">(*&nbsp;###################################&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab22"></a><h1 class="section">More on Notation (Advanced)</h1>

<div class="paragraph"> </div>

 In general, sections marked Advanced are not needed to follow the
    rest of the book, except possibly other Advanced sections.  On a
    first reading, you might want to skim these sections so that you
    know what's there for future reference. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> "x + y" := (<span class="id" type="var">plus</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 50, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> "x * y" := (<span class="id" type="var">mult</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="tactic">left</span> <span class="id" type="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">nat_scope</span>.<br/>

<br/>
</div>

<div class="doc">
For each notation-symbol in Coq we can specify its <i>precedence level</i>
    and its <i>associativity</i>. The precedence level n can be specified by the
    keywords <span class="inlinecode"><span class="id" type="tactic">at</span></span> <span class="inlinecode"><span class="id" type="keyword">level</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> and it is helpful to disambiguate
    expressions containing different symbols. The associativity is helpful
    to disambiguate expressions containing more occurrences of the same 
    symbol. For example, the parameters specified above for <span class="inlinecode">+</span> and <span class="inlinecode">×</span>
    say that the expression <span class="inlinecode">1+2*3*4</span> is a shorthand for the expression
    <span class="inlinecode">(1+((2*3)*4))</span>. Coq uses precedence levels from 0 to 100, and 
    <i>left</i>, <i>right</i>, or <i>no</i> associativity.

<div class="paragraph"> </div>

Cada símbolo de notação no Coq está também ativo num escopo de notação. 
O Coq tenta adivinhar a qual é escopo você se refere, de modo que, quando você 
escreve <span class="inlinecode"><span class="id" type="var">S</span>(<span class="id" type="var">O</span>×<span class="id" type="var">O</span>)</span>, ele advinha <span class="inlinecode"><span class="id" type="var">nat_scope</span></span>, mas quando você escreve o tipo 
produto cartesiano (tupla) <span class="inlinecode"><span class="id" type="var">bool</span>×<span class="id" type="var">bool</span></span>, ele advinha <span class="inlinecode"><span class="id" type="var">type_scope</span></span>. 
Ocasionalmente, você tem que ajudá-lo com uma notação de percentagem escrevendo 
<span class="inlinecode">(<span class="id" type="var">x</span>×<span class="id" type="var">y</span>)%<span class="id" type="var">nat</span></span>, e, algumas vezes, em suas respostas para você, o Coq usará <span class="inlinecode">%<span class="id" type="var">nat</span></span> 
para indicar em qual escopo se encontra a notação.

<div class="paragraph"> </div>

    Notation scopes also apply to numeral notation (3,4,5, etc.), so you
    may sometimes see <span class="inlinecode">0%<span class="id" type="var">nat</span></span> which means <span class="inlinecode"><span class="id" type="var">O</span></span>, or <span class="inlinecode">0%<span class="id" type="var">Z</span></span> which means the
    Integer zero.

<div class="paragraph"> </div>

<a name="lab23"></a><h1 class="section"><span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> and Structural Recursion (Advanced)</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">plus'</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">S</span> (<span class="id" type="var">plus'</span> <span class="id" type="var">n'</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
When Coq checks this definition, it notes that <span class="inlinecode"><span class="id" type="var">plus'</span></span> is
    "decreasing on 1st argument."  What this means is that we are
    performing a <i>structural recursion</i> over the argument <span class="inlinecode"><span class="id" type="var">n</span></span> -- i.e.,
    that we make recursive calls only on strictly smaller values of
    <span class="inlinecode"><span class="id" type="var">n</span></span>.  This implies that all calls to <span class="inlinecode"><span class="id" type="var">plus'</span></span> will eventually
    terminate.  Coq demands that some argument of <i>every</i> <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>
    definition is "decreasing".

<div class="paragraph"> </div>

    This requirement is a fundamental feature of Coq's design: In
    particular, it guarantees that every function that can be defined
    in Coq will terminate on all inputs.  However, because Coq's
    "decreasing analysis" is not very sophisticated, it is sometimes
    necessary to write functions in slightly unnatural ways. 
<div class="paragraph"> </div>

<a name="lab24"></a><h4 class="section">Exercise: 2 stars, optional (decreasing)</h4>
 To get a concrete sense of this, find a way to write a sensible
    <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> definition (of a simple function on numbers, say) that
    <i>does</i> terminate on all inputs, but that Coq will reject because
    of this restriction. 
</div>
<div class="code">

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>