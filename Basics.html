<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Basics</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Basics</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Embasamento: Programação Funcional em Coq</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">admit</span> {<span class="id" title="var">T</span>: <span class="id" title="keyword">Type</span>} : <span class="id" title="var">T</span>. <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">Introdução</h1>

<div class="paragraph"> </div>

 O estilo de programação funcional aproxima a programação à matemática
    simples do dia-a-dia: se um procedimento ou método não possui efeitos
    colaterais, então, basicamente, tudo que você precisa entender é como
    entradas são mapeadas para saídas -- isto é, você pode pensar nisto
    simplesmente como um método concreto para computar uma função
    matemática. Esse é um dos significados da palavra "funcional" em
    "programação funcional". A conexão direta entre programas e objetos
    matemáticos simples autoriza tanto provas formais de corretude quanto
    raciocínio informal de correção sobre o comportamento do programa.

<div class="paragraph"> </div>

    O outro sentido no qual a programação funcional é "funcional" é a 
    ênfase que ela dá ao uso de funções (ou métodos) como valores de 
    primeira classe, como por exemplo, valores que podem ser passados 
    como argumentos para outras funções, retornados como resultados, 
    guardados em estruturas de dados, etc. O entendimento de que funções 
    podem ser tratadas como dados dessa maneira permite uma série de
    idiomas úteis e poderosos.

<div class="paragraph"> </div>

    Outra característica comum das linguagens funcionais incluem <i>tipos de dados
    algébricos</i> e <i>casamento de padrão</i>, tornando fácil de construir e
    manipular estruturas de dados ricas, e sofistacados
    <i>sistemas de tipo polimórficos</i> que suportam abstração e reuso
    de código.  Coq compartilha de todas essas características.

<div class="paragraph"> </div>

    A primeira metade deste capítulo introduz os principais elementos da 
    linguagem de programação funcional de Coq. A segunda metade introduz algumas
    <i>táticas</i> basicas que podem ser usados para provar propriedades simples dos
    programas Coq.

<div class="paragraph"> </div>

<a name="lab3"></a><h1 class="section">Tipos Enumerados</h1>

<div class="paragraph"> </div>

 Um aspecto incomum de Coq é que o seu conjunto de recursos internos 
    é extremamente pequeno. Por exemplo, em vez de fornecer a paleta habitual 
    de tipos atômicos de dados (booleans, integers, strings, etc.), Coq oferece 
    um mecanismo extremamente poderoso para a definição de novos tipos de 
    dados a partir do zero - tão poderoso que todos estes tipos familiares 
    surgem como instâncias.  

<div class="paragraph"> </div>

    Naturalmente, a distribuição Coq vem com uma extensiva biblioteca padrão,
    fornecendo definições de booleanos, números e muitas outras estruturas de
    dados como listas e tabelas de dispersão. Mas não há nada de mágico ou
    primitivo sobre estas definições da biblioteca: elas foram implementadas com
    código simples de usuário. Para ilustrar isto, recapitularemos
    explicitamente todas as definições que precisarmos neste curso, ao invés de
    usar as definições da biblioteca.

<div class="paragraph"> </div>

    Para ver como este mecanismo funciona, começaremos com um exemplo muito
    simples.
<div class="paragraph"> </div>

<a name="lab4"></a><h2 class="section">Dias da Semana</h2>

<div class="paragraph"> </div>

 A declaração abaixo diz ao Coq que estamos definindo um novo conjunto
    de valores -- um tipo 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">day</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">monday</span> : <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">tuesday</span> : <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">wednesday</span> : <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">thursday</span> : <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">friday</span> : <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">saturday</span> : <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">sunday</span> : <span class="id" title="var">day</span>.<br/>

<br/>
</div>

<div class="doc">
O tipo é chamado <span class="inlinecode"><span class="id" title="var">day</span></span> (<i>dia</i>) e seus membros são <span class="inlinecode"><span class="id" title="var">monday</span></span>
    (<i>segunda-feira</i>), <span class="inlinecode"><span class="id" title="var">tuesday</span></span> (<i>terça-feira</i>), etc. A partir da segunda linha
    a definição pode ser lida como "<span class="inlinecode"><span class="id" title="var">monday</span></span> é um <span class="inlinecode"><span class="id" title="var">day</span></span>, <span class="inlinecode"><span class="id" title="var">tuesday</span></span> é um <span class="inlinecode"><span class="id" title="var">day</span></span>",
    etc.

<div class="paragraph"> </div>

    Uma vez definido <span class="inlinecode"><span class="id" title="var">day</span></span>, é possível escrever funções que operam com dias. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">next_weekday</span> (<span class="id" title="var">d</span>:<span class="id" title="var">day</span>) : <span class="id" title="var">day</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">monday</span>    ⇒ <span class="id" title="var">tuesday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">tuesday</span>   ⇒ <span class="id" title="var">wednesday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">wednesday</span> ⇒ <span class="id" title="var">thursday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">thursday</span>  ⇒ <span class="id" title="var">friday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">friday</span>    ⇒ <span class="id" title="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">saturday</span>  ⇒ <span class="id" title="var">monday</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">sunday</span>    ⇒ <span class="id" title="var">monday</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Algo notável é que o argumento e os tipos de retorno dessa
    função estão declaradas explicitamente.  Como a maioria das linguagens
    de programação funcional, Coq pode frequentemente descobrir esses tipos
    sózinho, quando eles não são dados explictamente -- isto é, ele executa
    uma <i>inferência de tipo</i> -- mas sempre devemos inclui-los para facilitar
    a leitura. 
<div class="paragraph"> </div>

 Tendo definido uma função, nós devemos checar que ela funciona em alguns
    exemplos. Na verdade existem três maneiras diferentes de fazer isso em Coq.

<div class="paragraph"> </div>

    Primeiro, nós podemos usar o comando <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> <span class="inlinecode"><span class="id" title="tactic">compute</span></span> (<i>avalia cálculo</i>) para
    avaliar uma expressão composta envolvendo <span class="inlinecode"><span class="id" title="var">next_weekday</span></span>.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">next_weekday</span> <span class="id" title="var">friday</span>).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">next_weekday</span> (<span class="id" title="var">next_weekday</span> <span class="id" title="var">saturday</span>)).<br/>

<br/>
</div>

<div class="doc">
Se você tiver um computador acessível, este seria um excelente 
    momento de disparar o interpretador Coq sob seu IDE favorito - 
    CoqIDE ou Proof General - e tentar isso por si próprio. Carregue 
    este arquivo (<span class="inlinecode"><span class="id" title="var">Basics.v</span></span>) a partir dos arquivos fontes do Coq anexos 
    ao livro, encontre o exemplo acima, submeta-o ao Coq, e observe 
    o resultado. 
<div class="paragraph"> </div>

 A palavra-chave <span class="inlinecode"><span class="id" title="tactic">compute</span></span> (<i>calcular</i>) informa ao Coq exatamente como
    avaliar as expressões que lhe damos. No momento, precisamos saber apenas
    sobre <span class="inlinecode"><span class="id" title="tactic">compute</span></span>; posteriormente veremos algumas alternativas que podem ser
    úteis em alguns casos.  
<div class="paragraph"> </div>

 A segunda maneira consiste em registrar o resultado <i>esperado</i> sob a a forma
    de um exemplo Coq: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_next_weekday</span>:<br/>
&nbsp;&nbsp;(<span class="id" title="var">next_weekday</span> (<span class="id" title="var">next_weekday</span> <span class="id" title="var">saturday</span>)) = <span class="id" title="var">tuesday</span>.<br/>

<br/>
</div>

<div class="doc">
Esta declaração faz duas coisas: define uma asserção de que o segundo dia da
    semana depois de <span class="inlinecode"><span class="id" title="var">saturday</span></span> (<i>sábado</i>) é <span class="inlinecode"><span class="id" title="var">tuesday</span></span> (<i>terça</i>), e dá a esta
    asserção um nome que pode ser usado para referenciá-la posteriormente. 
<div class="paragraph"> </div>

 Tendo feito essa asserção, também podemos pedir ao Coq para verificá-la da
    seguinte forma: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Os detalhes não são importantes por enquanto (voltaremos a considerá-los em
    breve), mas, essencialmente, isto pode ser lido como "A asserção que
    acabamos de fazer pode ser provada pela observação de que, após
    simplificação, o valor calculado em ambos os lados da igualdade é o mesmo."
    
<div class="paragraph"> </div>

 Por último, podemos pedir ao Coq para extrair da nossa <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>
    (definição), um programa em alguma outra linguagem de programação mais
    convencional (OCaml, Scheme, ou Haskell) com um compilador de alta
    performance. Essa facilidade é muito interessante, já que nos dá um modo de
    construir programas totalmente provados em liguagens mais comuns. De fato,
    esse é um dos principais usos para o qual Coq foi criado. Voltaremos a esse
    assunto em capítulos posteriores. Mais informações podem ser encontradas no
    livro "Coq'Art" de Bertot e Casteran, assim como no manual de referência de
    Coq. 
<div class="paragraph"> </div>

<a name="lab5"></a><h2 class="section">Booleanos</h2>

<div class="paragraph"> </div>

 De maneira similar, é possível definir um tipo padrão <span class="inlinecode"><span class="id" title="var">bool</span></span> de
    booleanos, com membros <span class="inlinecode"><span class="id" title="var">true</span></span> (<i>verdadeiro</i>) e <span class="inlinecode"><span class="id" title="var">false</span></span> (<i>falso</i>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> : <span class="id" title="var">bool</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> : <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
Apesar de estarmos rodando nossas próprias booleanas com o objetivo
    de construir tudo do zero, o Coq, é claro,
    provém uma implementação padrão de booleanas em sua biblioteca
    padrão, junto com uma grande quantidade de funções úteis e
    normas.  (Dê uma olhada em <span class="inlinecode"><span class="id" title="var">Coq.Init.Datatypes</span></span> na biblioteca documental
    do Coq se estiver interessado.)  Sempre que possível, nomearemos
    nossa própria definição e teoremas, então elas iream coincidir exatamente
    com as definições na biblioteca padrão. 
<div class="paragraph"> </div>

 Funções sobre booleanos podem ser definidos da mesma maneira como
    acima: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb</span> (<span class="id" title="var">b</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">andb</span> (<span class="id" title="var">b1</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b1</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">b2</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">orb</span> (<span class="id" title="var">b1</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b1</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">b2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The last two illustrate the syntax for multi-argument
    function definitions. 
<div class="paragraph"> </div>

 Os quatro seguintes "testes unitários" constituem uma especificação completa
 uma tabela verdade -- para a função <span class="inlinecode"><span class="id" title="var">orb</span></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb1</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">true</span>  <span class="id" title="var">false</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb2</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">false</span> <span class="id" title="var">false</span>) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb3</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">false</span> <span class="id" title="var">true</span>)  = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_orb4</span>:  (<span class="id" title="var">orb</span> <span class="id" title="var">true</span>  <span class="id" title="var">true</span>)  = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
(Observe que nós removemos o <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> nas provas. Ele não é
    realmente necessário porque <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> executa simplificação
    automaticamente.) 
<div class="paragraph"> </div>

 <i>Uma observação sobre anotações</i>: Em arquivos .v, utilizamos colchetes para
    delimitar fragmentos de código Coq nos comentários. O objetivo desta
    convenção, também usada pela ferramenta de documentação <span class="inlinecode"><span class="id" title="var">coqdoc</span></span>, é manter
    estes fragmentos visualmente diferentes do texto ao redor: na versão html
    dos arquivos, estas partes do texto aparecem com uma <span class="inlinecode"><span class="id" title="var">fonte</span></span> <span class="inlinecode"><span class="id" title="var">diferente</span></span>. 
<div class="paragraph"> </div>

 Os valores <span class="inlinecode"><span class="id" title="var">Admitted</span></span> (<i>admitido</i>) e <span class="inlinecode"><span class="id" title="var">admit</span></span> (<i>admitir</i>) podem ser usados
    para preencher um espaço em uma definição ou prova imcompletas. Usaremos
    tais valores nos próximos exercícios. Em geral, nossa tarefa nos exercícios
    é substituir <span class="inlinecode"><span class="id" title="var">admit</span></span> ou <span class="inlinecode"><span class="id" title="var">Admitted</span></span> por definições ou provas reais. 
<div class="paragraph"> </div>

<a name="lab6"></a><h4 class="section">* Exercício: <span class="inlinecode"><span class="id" title="var">nandb</span></span></h4>

<div class="paragraph"> </div>

 Complete a definição das seguintes funções, depois, certifique que as
    asserções <span class="inlinecode"><span class="id" title="keyword">Example</span></span> (<i>exemplo</i>) abaixo podem ser verificadas pelo Coq.  
<div class="paragraph"> </div>

 Essa função deve retornar <span class="inlinecode"><span class="id" title="var">true</span></span> (<i>verdadeiro</i>) se um ou todas as
    entradas sâo <span class="inlinecode"><span class="id" title="var">false</span></span> (<i>falso</i>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nandb</span> (<span class="id" title="var">b1</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
</div>

<div class="doc">
Remover "<span class="inlinecode"><span class="id" title="var">Admitted</span>.</span>" e preencher cada prova com
    "<span class="inlinecode"><span class="id" title="keyword">Proof</span>.</span> <span class="inlinecode"><span class="id" title="tactic">reflexivity</span>.</span> <span class="inlinecode"><span class="id" title="keyword">Qed</span>.</span>" 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb1</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">true</span> <span class="id" title="var">false</span>) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb2</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">false</span> <span class="id" title="var">false</span>) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb3</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">false</span> <span class="id" title="var">true</span>) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nandb4</span>:               (<span class="id" title="var">nandb</span> <span class="id" title="var">true</span> <span class="id" title="var">true</span>) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab7"></a><h4 class="section">* Exercício <span class="inlinecode"><span class="id" title="var">andb3</span></span></h4>
 Do the same for the <span class="inlinecode"><span class="id" title="var">andb3</span></span> function below. This function should
    return <span class="inlinecode"><span class="id" title="var">true</span></span> when all of its inputs are <span class="inlinecode"><span class="id" title="var">true</span></span>, and <span class="inlinecode"><span class="id" title="var">false</span></span>
    otherwise. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">andb3</span> (<span class="id" title="var">b1</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b2</span>:<span class="id" title="var">bool</span>) (<span class="id" title="var">b3</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_andb31</span>:                 (<span class="id" title="var">andb3</span> <span class="id" title="var">true</span> <span class="id" title="var">true</span> <span class="id" title="var">true</span>) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_andb32</span>:                 (<span class="id" title="var">andb3</span> <span class="id" title="var">false</span> <span class="id" title="var">true</span> <span class="id" title="var">true</span>) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_andb33</span>:                 (<span class="id" title="var">andb3</span> <span class="id" title="var">true</span> <span class="id" title="var">false</span> <span class="id" title="var">true</span>) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_andb34</span>:                 (<span class="id" title="var">andb3</span> <span class="id" title="var">true</span> <span class="id" title="var">true</span> <span class="id" title="var">false</span>) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab8"></a><h2 class="section">Tipos funcionais</h2>

<div class="paragraph"> </div>

 O comando <span class="inlinecode"><span class="id" title="keyword">Check</span></span> (<i>verifique</i>) faz com que Coq imprima o tipo de uma
    expressão. Por exemplo, o tipo de <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> é <span class="inlinecode"><span class="id" title="var">bool</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">negb</span> <span class="id" title="var">true</span>).<br/>

<br/>
</div>

<div class="doc">
Funções como <span class="inlinecode"><span class="id" title="var">negb</span></span> em si também são valores de dados, assim como <span class="inlinecode"><span class="id" title="var">true</span></span> e
    <span class="inlinecode"><span class="id" title="var">false</span></span>. Seus tipos são chamados <i>function types</i> (<i>tipos funcionais</i>), e
    eles são escritos com setas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">negb</span>.<br/>

<br/>
</div>

<div class="doc">
O tipo de <span class="inlinecode"><span class="id" title="var">negb</span></span>, escrito <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> e pronunciado 
    "<span class="inlinecode"><span class="id" title="var">bool</span></span> seta <span class="inlinecode"><span class="id" title="var">bool</span></span>," pode ser lido: "Dada uma entrada do tipo 
     <span class="inlinecode"><span class="id" title="var">bool</span></span>, esta função produz uma saída do tipo <span class="inlinecode"><span class="id" title="var">bool</span></span>." Da mesma 
    forma, o tipo de <span class="inlinecode"><span class="id" title="var">andb</span></span>, escrito <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>, pode ser 
    lido, "Dadas duas entradas, ambas do tipo <span class="inlinecode"><span class="id" title="var">bool</span></span>, esta função produz 
    uma saída do tipo <span class="inlinecode"><span class="id" title="var">bool</span></span>." 
<div class="paragraph"> </div>

<a name="lab9"></a><h2 class="section">Números</h2>

<div class="paragraph"> </div>

 <i>Digressão técnica</i>: O Coq fornece um <i>sistema modular</i> bastante sofisticado
    para auxiliar na organização de desenvolvimentos robustos. Neste curso não
    precisaremos da maioria de suas funcionalidades, mas uma é bastante útil: se
    inserimos uma coleção de declarações entre os marcadores <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> (<i>módulo
    X</i>) e <span class="inlinecode"><span class="id" title="keyword">End</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> (<i>término X</i>), então, no restante do arquivo após o <span class="inlinecode"><span class="id" title="keyword">End</span></span>,
    estas definições serão referenciadas através de nomes como <span class="inlinecode"><span class="id" title="var">X.foo</span></span> no lugar
    de <span class="inlinecode"><span class="id" title="var">foo</span></span>. Aqui, usaremos esta funcionalidade para introduzir a definição do
    tipo <span class="inlinecode"><span class="id" title="var">nat</span></span> em um módulo interno, para que a definição presente na biblioteca
    padrão não seja omitida. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Playground1</span>.<br/>

<br/>
</div>

<div class="doc">
Os tipos que definimos até o momento são exemplos de “tipos enumerados”:
    suas definições enumeram explicitamente um conjunto finito de elementos. Uma
    forma mais interessante de definir um tipo é através de uma coleção de
    "regras indutivas" descrevendo seus elementos. Por exemplo, podemos definir
    os números naturais desta forma: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
As cláusulas desta definição podem ser lidas como: 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">O</span></span> é um número natural (perceba que isto é a letra "<span class="inlinecode"><span class="id" title="var">O</span></span>", e não

</li>
</ul>
      o numeral "<span class="inlinecode">0</span>"). 

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">S</span></span> é um "construtor" que recebe um número natural e retorna um outro

</li>
</ul>
      número natural---isto é, se <span class="inlinecode"><span class="id" title="var">n</span></span> é um número natural, então <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> também
      o é.

<div class="paragraph"> </div>

    Vamos olhar isso com um pouco mais de detalhamento.

<div class="paragraph"> </div>

    Todo conjunto definido indutivamente (<span class="inlinecode"><span class="id" title="var">day</span></span>, <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span>, etc.) é
    na realidade um conjunto de <i>expressões</i>.  A definição de <span class="inlinecode"><span class="id" title="var">nat</span></span> diz como
    expressões do conjunto <span class="inlinecode"><span class="id" title="var">nat</span></span> podem ser construidas:

<div class="paragraph"> </div>

<ul class="doclist">
<li> a expressão <span class="inlinecode"><span class="id" title="var">O</span></span> pertence ao conjunto <span class="inlinecode"><span class="id" title="var">nat</span></span>; 

</li>
<li> se <span class="inlinecode"><span class="id" title="var">n</span></span> é uma expressão que pertence ao conjunto <span class="inlinecode"><span class="id" title="var">nat</span></span>, então <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
      é também uma expressão que pertence ao conjunto <span class="inlinecode"><span class="id" title="var">nat</span></span>; e

</li>
<li> expressões formadas nestas duas maneiras são os únicos que pertencem
      ao conjunto <span class="inlinecode"><span class="id" title="var">nat</span></span>.

</li>
</ul>
    The same rules apply for our definitions of <span class="inlinecode"><span class="id" title="var">day</span></span> and <span class="inlinecode"><span class="id" title="var">bool</span></span>. The
    annotations we used for their constructors are analogous to the
    one for the <span class="inlinecode"><span class="id" title="var">O</span></span> constructor, and indicate that each of those
    constructors doesn't take any arguments. 
<div class="paragraph"> </div>

 Estas três condições são a força precisa da declaração <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>. 
    Elas implicam que a expressão <span class="inlinecode"><span class="id" title="var">O</span></span>, a expressão <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span>, a expressão 
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>)</span>, a expressão <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">O</span>))</span>, e assim por diante, todas 
    pertencem ao conjunto <span class="inlinecode"><span class="id" title="var">nat</span></span>, enquanto outras expressões como <span class="inlinecode"><span class="id" title="var">true</span></span>, 
    <span class="inlinecode"><span class="id" title="var">andb</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> e <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">false</span>)</span> não.

<div class="paragraph"> </div>

    Nós podemos escrever funções simples que realizam casamento de padrões em
    números naturais assim como fizemos acima -- por exemplo, a função
    predecessor: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="var">n&acute;</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
O segundo ramo pode ser lido assim:"se <span class="inlinecode"><span class="id" title="var">n</span></span> possui a forma <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> para algum
    <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>, então retorne <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Playground1</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">minustwo</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">O</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span>) ⇒ <span class="id" title="var">n&acute;</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Como os números naturais são uma forma de informação difundida, Coq provê um
    pouquinho de mágica construída internamente para interpretá-los e
    imprimí-los: algarismos árabes comuns podem ser usados como alternativa para
    a notação "unária" definida pelos construtores <span class="inlinecode"><span class="id" title="var">S</span></span> e <span class="inlinecode"><span class="id" title="var">O</span></span>. Por padrão, Coq
    imprime números na forma árabe: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)))).<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">minustwo</span> 4).<br/>

<br/>
</div>

<div class="doc">
O construtor <span class="inlinecode"><span class="id" title="var">S</span></span> possui o tipo <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, assim como as funções
    <span class="inlinecode"><span class="id" title="var">minustwo</span></span> e <span class="inlinecode"><span class="id" title="var">pred</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">S</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">pred</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">minustwo</span>.<br/>

<br/>
</div>

<div class="doc">
Estas são todas as coisas que podem ser aplicadas a um número para obter
    outro número. Porém, existe uma diferença fundamental: funções como <span class="inlinecode"><span class="id" title="var">pred</span></span> e
    <span class="inlinecode"><span class="id" title="var">minustwo</span></span> vêm com <i>regras computacionais</i> -- por exemplo, a definição de
    <span class="inlinecode"><span class="id" title="var">pred</span></span> afirma que <span class="inlinecode"><span class="id" title="var">pred</span></span> <span class="inlinecode">2</span> pode ser simplificado para <span class="inlinecode">1</span> -- enquanto que a
    definição de <span class="inlinecode"><span class="id" title="var">S</span></span> não possui nenhum comportamento incorporado. Embora o
    último seja uma função no sentido de que pode ser aplicado a um argumento,
    ele realmente não <i>faz</i> nada!  
<div class="paragraph"> </div>

 Para muitas definições de funções sobre números, casamento de padrões puro
    não é suficiente: também precisamos de recursão. Por exemplo, para verificar
    que um número <span class="inlinecode"><span class="id" title="var">n</span></span> é par, precisamos verificar recursivamente se <span class="inlinecode"><span class="id" title="var">n</span>-2</span> é
    par. Para escrever essas funções, usamos a palavra-chave <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (<i>ponto
    fixo</i>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">evenb</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span>        ⇒ <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">O</span>      ⇒ <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span>) ⇒ <span class="id" title="var">evenb</span> <span class="id" title="var">n&acute;</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Podemos definir <span class="inlinecode"><span class="id" title="var">oddb</span></span> através de uma declaração <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> similar, mas
    aqui está uma definição mais simples com a qual será um pouco mais fácil de
    trabalhar: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">oddb</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span>   :=   <span class="id" title="var">negb</span> (<span class="id" title="var">evenb</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_oddb1</span>:    (<span class="id" title="var">oddb</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_oddb2</span>:    (<span class="id" title="var">oddb</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))))) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Naturalmente, também podemos definir funções com múltiplos argumentos
    através de recursão. (Mais uma vez, usamos um módulo para evitar a poluição
    do contexto para identificadores.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Playground2</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n&acute;</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Somar três com dois nos dá agora cinco, conforme esperado. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">plus</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))) (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))).<br/>

<br/>
</div>

<div class="doc">
A simplificação que o Coq realiza para chegar à essa conclusão pode ser
visualizada a seguir: 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Por convenção notacional, se dois ou mais argumentos têm o mesmo tipo, eles
    podem ser escritos juntos. Na definição à seguir, <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> significa
    apenas o mesmo que se tivéssemos escrito <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mult</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="var">plus</span> <span class="id" title="var">m</span> (<span class="id" title="var">mult</span> <span class="id" title="var">n&acute;</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_mult1</span>: (<span class="id" title="var">mult</span> 3 3) = 9.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Você pode casar duas expressões ao mesmo tempo colocando uma vírgula entre
    elas: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">minus</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span>   , <span class="id" title="var">_</span>    ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">_</span> , <span class="id" title="var">O</span>    ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span>, <span class="id" title="var">S</span> <span class="id" title="var">m&acute;</span> ⇒ <span class="id" title="var">minus</span> <span class="id" title="var">n&acute;</span> <span class="id" title="var">m&acute;</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
O _ na primeira linha é uma <i>padrão coringa</i>. Escrever _ em um padrão é o
    mesmo que escrever alguma variável que não será usada no lado direito. Isso
    evita a necessidade de inventar um nome falso de variável. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Playground2</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">exp</span> (<span class="id" title="var">base</span> <span class="id" title="var">power</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">power</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">S</span> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">p</span> ⇒ <span class="id" title="var">mult</span> <span class="id" title="var">base</span> (<span class="id" title="var">exp</span> <span class="id" title="var">base</span> <span class="id" title="var">p</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab10"></a><h4 class="section">* Exercício <span class="inlinecode"><span class="id" title="var">factorial</span></span></h4>
 Relembrando a função fatorial tradicional:
<pre>
    factorial(0)  =  1 
    factorial(n)  =  n * factorial(n-1)     (if n&gt;0)
</pre>
    Traduza isto em Coq. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">factorial</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := <br/>
 <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_factorial1</span>:          (<span class="id" title="var">factorial</span> 3) = 6.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_factorial2</span>:          (<span class="id" title="var">factorial</span> 5) = (<span class="id" title="var">mult</span> 10 12).<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Nós podemos tornar a leitura e a escrita de expressões numéricas
    mais fáceis ao introduzir "notações" para adição, multiplicação 
    e subtração. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x + y" := (<span class="id" title="var">plus</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x - y" := (<span class="id" title="var">minus</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x * y" := (<span class="id" title="var">mult</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> ((0 + 1) + 1).<br/>

<br/>
</div>

<div class="doc">
(As anotações <span class="inlinecode"><span class="id" title="keyword">level</span></span> (<i>nível</i>), <span class="inlinecode"><span class="id" title="keyword">associativity</span></span> ( associatividade), e
    <span class="inlinecode"><span class="id" title="var">nat_scope</span></span> controlam como essas notações são tratadas pelo analisador do
    Coq. Os detalhes não são importantes, mas leitores interessados podem se
    dirigir à subseção "Mais em Notações", na seção de "Material Avançado", no
    final desse capítulo.) 
<div class="paragraph"> </div>

 Note que estas não mudam as definições que já foram realizadas:
    elas são simplesmente instruções para que o analisador do Coq aceite <span class="inlinecode"><span class="id" title="var">x</span></span>
    <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span></span> no lugar de <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> e, reciprocamente, para que o Coq
    imprima <span class="inlinecode"><span class="id" title="var">plus</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> como <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
<div class="paragraph"> </div>

 Quando nós dizemos que Coq vem com nada embutido, nós realmente
    queremos dizer isso: até testar igualdade entre numéros é uma operação
    definida pelo usuário!  A função <span class="inlinecode"><span class="id" title="var">beq_nat</span></span> testa a igualdade (<span class="inlinecode"><span class="id" title="var">eq</span></span>) de números <span class="inlinecode"><span class="id" title="var">nat</span></span>urais, 
    fornecendo um <span class="inlinecode"><span class="id" title="var">b</span></span>ooleano.  Note o uso de <span class="inlinecode"><span class="id" title="keyword">match</span></span>es aninhados (nós também 
    podemos usar match simultaneamente, assim como fizemos em <span class="inlinecode"><span class="id" title="var">minus</span></span>.)  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">beq_nat</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m&acute;</span> ⇒ <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m&acute;</span> ⇒ <span class="id" title="var">beq_nat</span> <span class="id" title="var">n&acute;</span> <span class="id" title="var">m&acute;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, the <span class="inlinecode"><span class="id" title="var">ble_nat</span></span> function tests <span class="inlinecode"><span class="id" title="var">nat</span></span>ural numbers for
    <span class="inlinecode"><span class="id" title="var">l</span></span>ess-or-<span class="inlinecode"><span class="id" title="var">e</span></span>qual, yielding a <span class="inlinecode"><span class="id" title="var">b</span></span>oolean. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ble_nat</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m&acute;</span> ⇒ <span class="id" title="var">ble_nat</span> <span class="id" title="var">n&acute;</span> <span class="id" title="var">m&acute;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_ble_nat1</span>:             (<span class="id" title="var">ble_nat</span> 2 2) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_ble_nat2</span>:             (<span class="id" title="var">ble_nat</span> 2 4) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_ble_nat3</span>:             (<span class="id" title="var">ble_nat</span> 4 2) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab11"></a><h4 class="section">** Exercício <span class="inlinecode"><span class="id" title="var">blt_nat</span></span></h4>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="var">blt_nat</span></span> function tests <span class="inlinecode"><span class="id" title="var">nat</span></span>ural numbers for <span class="inlinecode"><span class="id" title="var">l</span></span>ess-<span class="inlinecode"><span class="id" title="var">t</span></span>han,
    yielding a <span class="inlinecode"><span class="id" title="var">b</span></span>oolean.  Instead of making up a new <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> for
    this one, define it in terms of a previously defined function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">blt_nat</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_blt_nat1</span>:             (<span class="id" title="var">blt_nat</span> 2 2) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_blt_nat2</span>:             (<span class="id" title="var">blt_nat</span> 2 4) = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_blt_nat3</span>:             (<span class="id" title="var">blt_nat</span> 4 2) = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab12"></a><h1 class="section">Prova por Simplificação</h1>

<div class="paragraph"> </div>

 Agora que nós definimos alguns tipos de dados e funções, vamos voltar 
    à questão de como declarar e provar propriedades de seu comportamento. 
    Na verdade, em certo sentido, nós já começamos a fazer isso: cada 
    <span class="inlinecode"><span class="id" title="keyword">Example</span></span> nas seções anteriores faz uma afirmação precisa sobre o 
    comportamento de alguma função para algumas entradas específicas. As 
    provas dessas afirmações eram sempre as mesmas: usar <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 
    para verificar que ambos os lados do <span class="inlinecode">=</span> são simplificados para 
    valores idênticos.

<div class="paragraph"> </div>

    (A propósito, posteriormente será útil saber que <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> na verdade 
    perfaz mais simplificação do que <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> -- por exemplo, ele tenta 
    "desdobrar" termos definidos, substituindo-os pelos seus lados direitos. A 
    razão para esta diferença é que, quando a aplicação da reflexividade é bem 
    sucedida, todo o objetivo é finalizado e não precisaremos visualizar as 
    expressões que foram expandidas por <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>. Em contrapartida, 
    <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> é usado em situações onde devemos ler e entender o objetivo, então 
    não queremos que definições sejam expandidas sem nosso conhecimento.) 

<div class="paragraph"> </div>

    O mesmo tipo de "prova por simplificação" também pode ser usado para provar
    propriedades mais interessantes. Por exemplo, o fato de que <span class="inlinecode">0</span> é um
    "elemento neutro" à esquerda para <span class="inlinecode">+</span> pode ser provado apenas pela
    observação de que <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> se reduz a <span class="inlinecode"><span class="id" title="var">n</span></span> para qualquer <span class="inlinecode"><span class="id" title="var">n</span></span>, um fato que pode
    ser lido diretamente à partir da definição de <span class="inlinecode"><span class="id" title="var">plus</span></span>.
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_O_n</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, 0 + <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
(<i>Nota</i>:Você pode perceber que a afirmação acima parece diferente no arquivo
    fonte original e no arquivo html final. Em arquivos Coq, escrevemos
    o quantificador universal <span class="inlinecode"><span class="id" title="keyword">∀</span></span> usando identificador reservado "<i>forall</i>".
    Isto é impresso como um "A" de cabeça para baixo, o símbolo habitualmente
    usado em lógica.) 
<div class="paragraph"> </div>

 As formas desse teorema e da prova são quase exatamente as mesmas
    que no exemplo acima; Existem somente algumas diferenças.

<div class="paragraph"> </div>

    Primeiramente, foi utilizado a palavra-chave <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> (<i>teorema</i>) no lugar
    de <span class="inlinecode"><span class="id" title="keyword">Example</span></span>.  De fato, a diferença é puramente um questão de estilo; as
    palavras-chave <span class="inlinecode"><span class="id" title="keyword">Example</span></span> e <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span>---e algumas outras, incluindo <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span>
    (<i>lema</i>), <span class="inlinecode"><span class="id" title="keyword">Fact</span></span> (<i>fato</i>), e <span class="inlinecode"><span class="id" title="keyword">Remark</span></span> ( observação)---significam exatamente
    a mesma coisa para o Coq.

<div class="paragraph"> </div>

    Em segundo lugar, nós adicionamos o quantificador <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">nat</span></span>, 
    assim o nosso teorema fala sobre <i>todos</i> os números naturais <span class="inlinecode"><span class="id" title="var">n</span></span>. A fim de
    provar teoremas desta forma, nós precisamos ser capaz de assumir a razão
    pela existência de um número natural arbitrário <span class="inlinecode"><span class="id" title="var">n</span></span>. Isto é alcançado
    na prova por <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, que move um quantificador a partir da meta de um
    "contexto" de suposiçoẽs atuais. Na realidade, nós inicializamos a prova
    dizendo "OK, suponha que <span class="inlinecode"><span class="id" title="var">n</span></span> é algum número arbitrário."

<div class="paragraph"> </div>

    As palavras-chave <span class="inlinecode"><span class="id" title="tactic">intros</span></span>, <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> e <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> são exemplos 
    de <i>táticas</i>. Uma tática é um comando que é usado entre <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> e <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> 
    para dizer ao Coq como ele deve verificar a correção de algumas afirmações 
    que estamos fazendo. Veremos mais algumas táticas no resto desta 
    lição, e ainda mais em lições futuras. 
<div class="paragraph"> </div>

 Poderíamos provar um teorema similar sobre <span class="inlinecode"><span class="id" title="var">plus</span></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> + 0 = <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
Porém, diferentemente da prova anterior, <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> não faz nada neste caso 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
(Você consegue explicar por que isto acontece? Percorra ambas as provas com Coq e perceba como o objetivo e o contexto mudam.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_1_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>, 1 + <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_l</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>, 0 × <span class="id" title="var">n</span> = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h1 class="section">Prova por Reescrita</h1>

<div class="paragraph"> </div>

 Eis um teorema um pouco mais interessante: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_id_example</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + <span class="id" title="var">n</span> = <span class="id" title="var">m</span> + <span class="id" title="var">m</span>.<br/>

<br/>
</div>

<div class="doc">
Ao invés de fazer um asserção completamente universal sobre todos os números
    naturais <span class="inlinecode"><span class="id" title="var">n</span></span> e <span class="inlinecode"><span class="id" title="var">m</span></span>, este teorema versa sobre uma propriedade mais
    especializada, que apenas é satisfeita quando <span class="inlinecode"><span class="id" title="var">n</span>=<span class="id" title="var">m</span></span>. O símbolo de seta é
    pronunciado "implica".

<div class="paragraph"> </div>

    Como anteriormente, nós precisamos ser capazes de supor a existência de
    números naturais <span class="inlinecode"><span class="id" title="var">n</span></span> e <span class="inlinecode"><span class="id" title="var">m</span></span>. Também precisamos supor a hipótese <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. A
    tática <span class="inlinecode"><span class="id" title="tactic">intros</span></span> será utilizada para deslocar essas três afirmações da meta
    para tornarem-se hipóteses do contexto atual.

<div class="paragraph"> </div>

    Como <span class="inlinecode"><span class="id" title="var">n</span></span> e <span class="inlinecode"><span class="id" title="var">m</span></span> são números quaisquer, não podemos utilizar apenas
    simplificação para provar este teorema. Ao invés, faremos esta prova
    lançando mão do fato que, ao supor <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, é possível substituir <span class="inlinecode"><span class="id" title="var">n</span></span> por
    <span class="inlinecode"><span class="id" title="var">m</span></span> na expressão meta, de forma que obtenhamos uma igualdade com a mesma
    expressão em ambos lados. A tática que instrui Coq de realizar esta
    substituição é chamada <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> (<i>reescrever</i>). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>. &nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. &nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">H</span>. &nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A primeira linha da prova desloca as variáveis universalmente quantificadas
    <span class="inlinecode"><span class="id" title="var">n</span></span> e <span class="inlinecode"><span class="id" title="var">m</span></span> para o contexto.  A segunda linha desloca a hipótese <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> para
    o contexto e atribui a ela o nome <span class="inlinecode"><span class="id" title="var">H</span></span> (qualquer nome poderia ter sido
    usado). A terceira linha instrui Coq para reescrever a meta atual (<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>), substituindo o lado esquerdo da igualdade hipótese <span class="inlinecode"><span class="id" title="var">H</span></span> pelo seu
    lado direito.

<div class="paragraph"> </div>

    (O símbolo da seta no <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> não tem nada a ver com
    implicação: ele informa ao Coq para aplicar a reescrita da esquerda para 
    a direita. Para reescrever da direita para a esquerda, você pode usasr
    <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">&lt;-</span>. Tente fazer esta mudança na prova acima e veja qual a
    diferença feita no comportamento de Coq.) 
<div class="paragraph"> </div>

<a name="lab14"></a><h4 class="section">* Exercício <span class="inlinecode"><span class="id" title="var">plus_id_exercise</span></span></h4>
 Remover "<span class="inlinecode"><span class="id" title="var">Admitted</span>.</span>" e preencher na prova. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_id_exercise</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> = <span class="id" title="var">m</span> → <span class="id" title="var">m</span> = <span class="id" title="var">o</span> → <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">o</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Como vimos nos exemplos anteriores, o comando <span class="inlinecode"><span class="id" title="var">Admitted</span></span> informa a Coq que
    queremos pular a tentativa de prova do teorema e simplesmente aceitar a
    declaração dada. Isto pode ser útil no desenvolvimento de provas mais
    longas, uma vez que podemos determinar fatos subsidiários que acreditamos
    serem importantes na criação de argumentos maiores. Use <span class="inlinecode"><span class="id" title="var">Admitted</span></span> para
    aceitar estes teoremas na fé do momento, e continuar pensando no argumento
    maior até termos certeza de que faz sentido; e então, poderemos voltar e
    concluir as provas incompletas. Porém tenha cuidado: Toda vez que você usa <span class="inlinecode"></span>
    <span class="inlinecode"><span class="id" title="var">Admitted</span></span> (ou <span class="inlinecode"><span class="id" title="var">admit</span></span>) você está deixando uma porta aberta para que um
    disparate total entre no mundo formal, rigoroso, verificado e agradável do
    Coq. 
<div class="paragraph"> </div>

 Também podemos usar a tática <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> com um teorema provado anteriormente
    ao invés de uma hipótese do contexto. 
</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_plus</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;(0 + <span class="id" title="var">n</span>) × <span class="id" title="var">m</span> = <span class="id" title="var">n</span> × <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">plus_O_n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h4 class="section">** Exercício <span class="inlinecode"><span class="id" title="var">mult_S_1</span></span></h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_S_1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">m</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span> → <br/>
&nbsp;&nbsp;<span class="id" title="var">m</span> × (1 + <span class="id" title="var">n</span>) = <span class="id" title="var">m</span> × <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab16"></a><h1 class="section">Prova por Análise de Casos</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Dalay</span></span> Of course, not everything can be proved by simple
    calculation: In general, unknown, hypothetical values (arbitrary
    numbers, booleans, lists, etc.) can block the calculation.  
    For example, if we try to prove the following fact using the 
    <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> tactic as above, we get stuck. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_1_neq_0_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">beq_nat</span> (<span class="id" title="var">n</span> + 1) 0 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
The reason for this is that the definitions of both
    <span class="inlinecode"><span class="id" title="var">beq_nat</span></span> and <span class="inlinecode">+</span> begin by performing a <span class="inlinecode"><span class="id" title="keyword">match</span></span> on their first
    argument.  But here, the first argument to <span class="inlinecode">+</span> is the unknown
    number <span class="inlinecode"><span class="id" title="var">n</span></span> and the argument to <span class="inlinecode"><span class="id" title="var">beq_nat</span></span> is the compound
    expression <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>; neither can be simplified.

<div class="paragraph"> </div>

    É preciso considerar as possíveis formas de <span class="inlinecode"><span class="id" title="var">n</span></span>
    separadamente.  Se <span class="inlinecode"><span class="id" title="var">n</span></span> é <span class="inlinecode"><span class="id" title="var">O</span></span>, então é possível calcular o resultado final
    de <span class="inlinecode"><span class="id" title="var">beq_nat</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> e verificar se é, de fato, <span class="inlinecode"><span class="id" title="var">false</span></span>.
    E se <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> para algum <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>, então, embora nós não saberemos
    exatamente qual é o número <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>, podemos calcular que, pelo
    menos, irá começar com um <span class="inlinecode"><span class="id" title="var">S</span></span>, e isso é suficiente para calcular que, 
    novamente, <span class="inlinecode"><span class="id" title="var">beq_nat</span></span> <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> <span class="inlinecode">0</span> será <span class="inlinecode"><span class="id" title="var">false</span></span>.

<div class="paragraph"> </div>

    A tática que informa ao Coq para considerar, separadamente, os 
    casos onde <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span> e <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n&acute;</span></span> é chamado de <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_1_neq_0</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">beq_nat</span> (<span class="id" title="var">n</span> + 1) 0 = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
O <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> gera <i>duas</i> submetas, ao qual nós devemos provar,
    separadamente, a fim de Coq aceitar o teorema como provado.
    (Nenhum comando especial é necessário para mover de uma submeta
    para a outra. Quando a primeira submeta é provado, ele apenas
    desaparece e nós ficamos com a outra "em foco.") Nesta prova, 
    cada uma das submetas é facilmente provado pelo uso simples de
    <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>.

<div class="paragraph"> </div>

    A anotação "<span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&acute;]</span>" é chamada de <i>padrão de introdução</i>. Ela 
    diz ao Coq quais nomes de variáveis devem ser introduzidos em cada 
    sub-objetivo. Em geral, o que se informa entre os colchetes é uma 
    <i>lista</i> de listas de nomes, separados por <span class="inlinecode">|</span>. Aqui, o primeiro 
    componente está vazio, uma vez que o construtor <span class="inlinecode"><span class="id" title="var">O</span></span> tem aridade zero
    (não carrega nenhuma informação). O segundo componente dá um único nome, 
    <span class="inlinecode"><span class="id" title="var">n&acute;</span></span>, uma vez que <span class="inlinecode"><span class="id" title="var">S</span></span> é um construtor unário.

<div class="paragraph"> </div>

    A tática <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> pode ser usada com qualquer tipo de dado definido
    indutivamente. Por exemplo, nós podemos usá-lo aqui para provar que a
    negação booleana é involutiva – isto é, que a negação é a sua própria
    inversa. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_involutive</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note que <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> aqui não possui nenhuma cláusula <span class="inlinecode"><span class="id" title="keyword">as</span></span> pois nenhum dos
    subcasos de <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> precisa ser vinculado a nenhuma das variáveis. Por
    isso, não há necessidade de especificar nenhum nome (Poderíamos ter escrito
    também <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[|]</span>, ou <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[]</span>). De fato, podemos omitir a cláusula <span class="inlinecode"><span class="id" title="keyword">as</span></span> de
    qualquer <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> e Coq irá preencher automaticamente os nomes de
    variáveis. Embora seja conveniente, isto é indiscutivelmente um estilo ruim,
    uma vez que o Coq pode fazer escolhas confusas de nomes quando lhe é deixada
    esta decisão. 
<div class="paragraph"> </div>

<a name="lab17"></a><h4 class="section">* Exercício <span class="inlinecode"><span class="id" title="var">zero_nbeq_plus_1</span></span></h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">zero_nbeq_plus_1</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">beq_nat</span> 0 (<span class="id" title="var">n</span> + 1) = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab18"></a><h1 class="section">Mais Exercícios</h1>

<div class="paragraph"> </div>

<a name="lab19"></a><h4 class="section">** Exercício (funções booleanas)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">Dalay</span></span> Use the tactics you have learned so far to prove the following 
    theorem about boolean functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">identity_fn_applied_twice</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">f</span> : <span class="id" title="var">bool</span> → <span class="id" title="var">bool</span>), <br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> : <span class="id" title="var">bool</span>), <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">x</span>) →<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>), <span class="id" title="var">f</span> (<span class="id" title="var">f</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Now state and prove a theorem <span class="inlinecode"><span class="id" title="var">negation_fn_applied_twice</span></span> similar
    to the previous one but where the second hypothesis says that the
    function <span class="inlinecode"><span class="id" title="var">f</span></span> has the property that <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">negb</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab20"></a><h4 class="section">** Exercício <span class="inlinecode"><span class="id" title="var">andb_eq_orb</span></span></h4>

<div class="paragraph"> </div>

 Prove o seguinte teorema.  (Você pode querer provar um lema
    subsidiário ou dois. De maneira alternativa, lembre que você
    não tem que intruduzir todas as hipóteses ao mesmo tempo.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_eq_orb</span> : <br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">bool</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">andb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> = <span class="id" title="var">orb</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>) →<br/>
&nbsp;&nbsp;<span class="id" title="var">b</span> = <span class="id" title="var">c</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab21"></a><h4 class="section">*** Exercício <span class="inlinecode"><span class="id" title="var">binário</span></span></h4>

<div class="paragraph"> </div>

 Considere uma diferente, representação mais eficiente dos
    números natural usando um sistema binário em vez de um sistema unário.
    Isto é, em vez de dizer que cada número natural ou é zero ou é o sucessor
    de um número natural, nós podemos dizer que cada número binário é ou

<div class="paragraph"> </div>

<ul class="doclist">
<li> zero,

</li>
<li> duas vezes um número binário, ou

</li>
<li> um a mais do que duas vezes um número binário.

</li>
</ul>

<div class="paragraph"> </div>

    (a) Primeiro, escreva uma definição indutiva para o tipo <span class="inlinecode"><span class="id" title="var">bin</span></span> que
    corresponda a esta descrição de números binários.

<div class="paragraph"> </div>

    (Dica : Lembre-se que a definição de <span class="inlinecode"><span class="id" title="var">nat</span></span>,
    Inductive nat : Type :=
      | O : nat
      | S : nat -&gt; nat.
    não diz nada quanto ao "significado" de <span class="inlinecode">0</span> e <span class="inlinecode"><span class="id" title="var">S</span></span>. Ela diz apenas que "<span class="inlinecode">0</span>
    está no conjunto chamado <span class="inlinecode"><span class="id" title="var">nat</span></span>, e se <span class="inlinecode"><span class="id" title="var">n</span></span> está neste conjunto então <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
    também está." A interpretação de <span class="inlinecode">0</span> como zero e <span class="inlinecode"><span class="id" title="var">S</span></span> como sucessor/mais um
    vem do modo como <i>usamos</i> os valores <span class="inlinecode"><span class="id" title="var">nat</span></span>, escrevendo funções para
    utilizá-los, provando coisas sobre eles e assim por diante. Sua definição de
    <span class="inlinecode"><span class="id" title="var">bin</span></span> deve ser correspondentemente simples; seu significado matemático será
    dado pelas funções que você escreverá à seguir.)

<div class="paragraph"> </div>

    (b) Depois, escreva uma função incrementa <span class="inlinecode"><span class="id" title="var">incr</span></span> para números binários, 
        e uma função <span class="inlinecode"><span class="id" title="var">bin_to_nat</span></span> para converter números binários para
        números unários.

<div class="paragraph"> </div>

    (c) Escreva cinco testes unitários <span class="inlinecode"><span class="id" title="var">test_bin_incr1</span></span>, <span class="inlinecode"><span class="id" title="var">test_bin_incr2</span></span>, 
    etc., para suas funções de incremento e de conversão binário-unário. 
    Observe que incrementar um número binário e, em seguida, convertê-lo 
    para unário deve produzir o mesmo resultado que o de primeiro convertê-lo 
    para unário e, em seguida, incrementá-lo.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab22"></a><h1 class="section">Mais sobre <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> (avançado)</h1>

<div class="paragraph"> </div>

 Em geral, seções marcadas como "Avançado" não são necessárias para
 compreender o restante do livro, exceto, talvez, entender outras
 seções avançadas. Você pode fazer uma leitura superficial ao passar
 pela primeira vez na seção, para que saiba o que esta escrito num
 momento futuro. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x + y" := (<span class="id" title="var">plus</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x * y" := (<span class="id" title="var">mult</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">nat_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Para cada tipo de símbolo de notação no Coq, podemos especificar
 seu <i>nível de precedência</i>. O nível de precedência n pode ser
 especificado pelas palavras-chave <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode"><span class="id" title="keyword">level</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> e é útil para
 desambiguizar expressões que contêm símbolos diferentes. A
 associatividade é útil para desambiguizar expressões que contêm mais
 de uma ocorrência de um mesmo símbolo. Por exemplo, os parâmetros
 definidos acima para <span class="inlinecode">+</span> e <span class="inlinecode">×</span> afirmam que a expressão <span class="inlinecode">1+2*3*4</span> é
 uma abreviação para <span class="inlinecode">(1+((2*3)*4))</span>. Coq usa níveis de precedência de
 0 a 100 e associatividade <i>esquerda</i> ou <i>direita</i> ou <i>nenhuma</i> associatividade.

<div class="paragraph"> </div>

    Cada símbolo de notação no Coq está também ativo num escopo de notação.  O
    Coq tenta descobrir a qual escopo é feito referência, de modo que, quando
    você escreve <span class="inlinecode"><span class="id" title="var">S</span>(<span class="id" title="var">O</span>×<span class="id" title="var">O</span>)</span>, ele infere <span class="inlinecode"><span class="id" title="var">nat_scope</span></span>, mas quando você escreve o
    tipo produto cartesiano (produto cartesiano) <span class="inlinecode"><span class="id" title="var">bool</span>×<span class="id" title="var">bool</span></span>, ele infere
    <span class="inlinecode"><span class="id" title="var">type_scope</span></span>.  Ocasionalmente, você tem que ajudá-lo com uma notação de
    percentagem escrevendo <span class="inlinecode">(<span class="id" title="var">x</span>×<span class="id" title="var">y</span>)%<span class="id" title="var">nat</span></span>, e, algumas vezes, em suas respostas para
    você, o Coq usará <span class="inlinecode">%<span class="id" title="var">nat</span></span> para indicar em qual escopo se encontra a notação.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">Dalay</span></span> Notation scopes also apply to numeral notation (3,4,5, etc.), so you
    may sometimes see <span class="inlinecode">0%<span class="id" title="var">nat</span></span> which means <span class="inlinecode"><span class="id" title="var">O</span></span>, or <span class="inlinecode">0%<span class="id" title="var">Z</span></span> which means the Integer
    zero.  
<div class="paragraph"> </div>

<a name="lab23"></a><h1 class="section"><span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> e Recursão Estrutural (Avançado)</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus&acute;</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">plus&acute;</span> <span class="id" title="var">n&acute;</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
When Coq checks this definition, it notes that <span class="inlinecode"><span class="id" title="var">plus&acute;</span></span> is
    "decreasing on 1st argument."  What this means is that we are
    performing a <i>structural recursion</i> over the argument <span class="inlinecode"><span class="id" title="var">n</span></span> -- i.e.,
    that we make recursive calls only on strictly smaller values of
    <span class="inlinecode"><span class="id" title="var">n</span></span>.  This implies that all calls to <span class="inlinecode"><span class="id" title="var">plus&acute;</span></span> will eventually
    terminate.  Coq demands that some argument of <i>every</i> <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>
    definition is "decreasing".

<div class="paragraph"> </div>

    Esse requisito é uma característica fundamental do projeto do Coq: em
    particular, isso garante que toda função que pode ser definida
    no Coq irá funcionar com todas as entradas.  Entretanto, como o
    "analisador de decaimento" do Coq não é muito sofisticado, algumas vezes
    é necessário escrever funções de uma maneira não natural. 
<div class="paragraph"> </div>

<a name="lab24"></a><h4 class="section">** Exercício opcional (decaimento)</h4>

<div class="paragraph"> </div>

 Para obter uma noção concreta disso, encontre uma maneira de escrever 
    uma definição <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> sensata (de uma função simples em números, 
    por exemplo) que <i>de fato</i> termine para todas as entradas, mas que Coq irá 
    rejeitar por causa dessa restrição. 
</div>
<div class="code">

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>