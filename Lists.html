<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Lists</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Lists</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Listas: Trabalhando com Dados Estruturados</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="keyword">Induction</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatList</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">Pares de Números</h1>

<div class="paragraph"> </div>

 Em uma definição de tipo indutivo usando <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, cada construtor pode
ter qualquer número de argumentos -- nenhum (como ocorre com <span class="inlinecode"><span class="id" title="var">true</span></span> e <span class="inlinecode">0</span>), um
(como ocorre com <span class="inlinecode"><span class="id" title="var">S</span></span>), ou mais de um, como na seguinte definição: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natprod</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">pair</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="var">natprod</span>.<br/>

<br/>
</div>

<div class="doc">
Essa declaração pode ser lida como: há somente um caminho para 
    construir um par de numeros: aplicando o construtor <span class="inlinecode"><span class="id" title="var">pair</span></span> 
    (<i>par</i>) a dois argumentos do tipo <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
<div class="paragraph"> </div>

 Nós podemos construir um elemento de <span class="inlinecode"><span class="id" title="var">natprod</span></span> dessa maneira: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">pair</span> 3 5).<br/>

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Aqui estão duas simples definições de função para extrair o
    primeiro e o segundo componente de um par. (As definições também
    ilustram como fazer o casamento de padrões com dois argumentos.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fst</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snd</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">fst</span> (<span class="id" title="var">pair</span> 3 5)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Dado que pares são bastante usados, é bom ser capaz de escrevê-los 
    com a notação matemática padrão <span class="inlinecode">(<span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">y</span>)</span> em vez de <span class="inlinecode"><span class="id" title="var">pair</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
    Podemos instruir o Coq para permitir isso com uma declaração 
    <span class="inlinecode"><span class="id" title="keyword">Notation</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;( x , y )" := (<span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>

<br/>
</div>

<div class="doc">
A nova notação pode ser usada tanto em expressões quanto no
 casamento de padrões (de fato, nós ja vimos isto no capítulo anterior
 esta notação é disponibilizada pela biblioteca padrão): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">fst</span> (3,5)).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fst&acute;</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snd&acute;</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">swap_pair</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">natprod</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ (<span class="id" title="var">y</span>,<span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Vamos testar e provar alguns fatos simples sobre pares. Se definirmos os
lemas de uma forma particular (e um pouco peculiar), podemos prová-los apenas
usando reflexividade (e sua simplificação implícita): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">surjective_pairing&acute;</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span>,<span class="id" title="var">m</span>) = (<span class="id" title="var">fst</span> (<span class="id" title="var">n</span>,<span class="id" title="var">m</span>), <span class="id" title="var">snd</span> (<span class="id" title="var">n</span>,<span class="id" title="var">m</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Note</span></span> <span class="inlinecode"><span class="id" title="var">que</span></span> <span class="inlinecode">[<span class="id" title="tactic">reflexivity</span>]</span> <span class="inlinecode"><span class="id" title="var">não</span></span> <span class="inlinecode"><span class="id" title="var">é</span></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">suficiente</span></span> <span class="inlinecode"><span class="id" title="var">se</span></span> <span class="inlinecode"><span class="id" title="var">nós</span></span> <span class="inlinecode"><span class="id" title="var">declararmos</span></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">lema</span></span>
    <span class="inlinecode"><span class="id" title="var">de</span></span> <span class="inlinecode"><span class="id" title="var">um</span></span> <span class="inlinecode"><span class="id" title="var">modo</span></span> <span class="inlinecode"><span class="id" title="var">mais</span></span> <span class="inlinecode"><span class="id" title="var">natural</span>:</span> <span class="inlinecode"></span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">surjective_pairing_stuck</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">p</span> = (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>, <span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h3 class="section"> </h3>
 Nós temos que expor a estrutura de <span class="inlinecode"><span class="id" title="var">p</span></span>, de tal maneira que <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 
    possa realizar o casamento de padrão em <span class="inlinecode"><span class="id" title="var">fst</span></span> e em <span class="inlinecode"><span class="id" title="var">snd</span></span>.  
    Nós podemos fazer isso através de <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>.

<div class="paragraph"> </div>

    Notar que, ao contrário para <span class="inlinecode"><span class="id" title="var">nat</span></span>s, <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> não gera uma
    submeta extra aqui.  Isso porque <span class="inlinecode"><span class="id" title="var">natprod</span></span>s pode apenas ser contruído
    de uma única maneira.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">surjective_pairing</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">p</span> = (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>, <span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">m</span>]. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h4 class="section">Exercício: * (<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">snd_fst_is_swap</span></span> <span class="inlinecode"></span>)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">snd_fst_is_swap</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">snd</span> <span class="id" title="var">p</span>, <span class="id" title="var">fst</span> <span class="id" title="var">p</span>) = <span class="id" title="var">swap_pair</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab8"></a><h4 class="section">Exercício: *, opcional (<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">fst_swap_is_snd</span></span> <span class="inlinecode"></span>)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">fst_swap_is_snd</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">fst</span> (<span class="id" title="var">swap_pair</span> <span class="id" title="var">p</span>) = <span class="id" title="var">snd</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab9"></a><h1 class="section">Listas de Números</h1>

<div class="paragraph"> </div>

 Generalizando a definição de pares um pouco, podemos descrever 
    o tipo de <i>listas</i> de números da seguinte forma: "A lista é ou 
    a lista vazia ou então um par contendo um número e outra 
    lista." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natlist</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> : <span class="id" title="var">natlist</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">cons</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">natlist</span> → <span class="id" title="var">natlist</span>.<br/>

<br/>
</div>

<div class="doc">
Por exemplo, se encontra abaixo uma lista de três elementos: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist</span> := <span class="id" title="var">cons</span> 1 (<span class="id" title="var">cons</span> 2 (<span class="id" title="var">cons</span> 3 <span class="id" title="var">nil</span>)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab10"></a><h3 class="section"> </h3>
 Tal como acontece com os pares, é mais conveniente escrever listas usando
notações habituais de programação. As duas declarações à seguir nos permitem
usar <span class="inlinecode">::</span> como um operador infixo <span class="inlinecode"><span class="id" title="var">cons</span></span> e colchetes como uma notação "externa"
para a construção de listas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x :: l" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[ ]" := <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ x ; .. ; y ]" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> .. (<span class="id" title="var">cons</span> <span class="id" title="var">y</span> <span class="id" title="var">nil</span>) ..).<br/>

<br/>
</div>

<div class="doc">
Não é necessário entender completamente essas declarações, mas, no caso
    de você estar interessado, aqui está rapidamente o que está acontecendo.

<div class="paragraph"> </div>

    A anotação <span class="inlinecode"><span class="id" title="tactic">right</span></span> <span class="inlinecode"><span class="id" title="keyword">associativity</span></span> (<i>associatividade à direita</i>) diz ao Coq
    como utilizar parênteses em expressões envolvendo o uso de muitos <span class="inlinecode">::</span>, 
    então, por exemplo, as três próximas declarações significam exatamente a mesma coisa: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist1</span> := 1 :: (2 :: (3 :: <span class="id" title="var">nil</span>)).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist2</span> := 1 :: 2 :: 3 :: <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist3</span> := [1;2;3].<br/>

<br/>
</div>

<div class="doc">
A parte <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode"><span class="id" title="keyword">level</span></span> <span class="inlinecode">60</span> instrui Coq como colocar interpretar
    expressões que envolvem ambos <span class="inlinecode">::</span> e algum outro operador infixo.
    Por exemplo, desde nós definimos <span class="inlinecode">+</span> como uma notação infixa para a 
    função <span class="inlinecode"><span class="id" title="var">plus</span></span> no nível 50,
Notation "x + y" := (plus x y)  
                    (at level 50, left associativity).
   O operador <span class="inlinecode">+</span> irá fazer uma ligação mais forte do que <span class="inlinecode">::</span>, então <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>
   será analisada, como nós esperamos, como <span class="inlinecode">(1</span> <span class="inlinecode">+</span> <span class="inlinecode">2)</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span> em vez de <span class="inlinecode">1</span>
   <span class="inlinecode">+</span> <span class="inlinecode">(2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3])</span>.

<div class="paragraph"> </div>

   (A propósito, vale a pena notar de passagem que expressões como "<span class="inlinecode">1</span>
<span class="inlinecode">   </span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>" podem ser um pouco confusas quando você as lê em um 
    arquivo .v. Os colchetes internos, cerca de 3, indicam uma lista, 
    porém os colchetes externos, que são invisíveis na renderização 
    do HTML, estão lá para instruir à ferramenta "coqdoc" que a 
    parte entre colchetes deve ser exibida como código Coq em vez 
    de texto comum.)

<div class="paragraph"> </div>

A segunda e a terceira declaração de <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> acima introduzem a
 notação padrão de colchetes para listas; o lado direito da terceira
 declaração ilustra a sintaxe do Coq para declarar notações n-árias  e
 traduzi-las para sequências aninhadas de construtores binários. 
<div class="paragraph"> </div>

<a name="lab11"></a><h3 class="section">Repetição</h3>

<div class="paragraph"> </div>

 Algumas funções são úteis para a manipulação de listas. Por exemplo,
  a função <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> recebe os números <span class="inlinecode"><span class="id" title="var">n</span></span> e <span class="inlinecode"><span class="id" title="var">count</span></span> e retorna uma lista com
  comprimento <span class="inlinecode"><span class="id" title="var">count</span></span> e elementos <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="tactic">repeat</span> (<span class="id" title="var">n</span> <span class="id" title="var">count</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">count</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">count&acute;</span> ⇒ <span class="id" title="var">n</span> :: (<span class="id" title="tactic">repeat</span> <span class="id" title="var">n</span> <span class="id" title="var">count&acute;</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h3 class="section">Comprimento</h3>

<div class="paragraph"> </div>

 A função <span class="inlinecode"><span class="id" title="var">length</span></span> (comprimento) calcula o comprimento de uma lista. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">length</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h3 class="section">Concatenação</h3>
 A função <span class="inlinecode"><span class="id" title="var">app</span></span> "append" (<i>anexar</i>) concatena duas listas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">app</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span> :: (<span class="id" title="var">app</span> <span class="id" title="var">t</span> <span class="id" title="var">l2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
De fato, <span class="inlinecode"><span class="id" title="var">app</span></span> será muito usado em algumas partes do que vem
    a seguir, então é conveniente ter um operador infixo para ele. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x ++ y" := (<span class="id" title="var">app</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app1</span>:             [1;2;3] ++ [4;5] = [1;2;3;4;5].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app2</span>:             <span class="id" title="var">nil</span> ++ [4;5] = [4;5].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app3</span>:             [1;2;3] ++ <span class="id" title="var">nil</span> = [1;2;3].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Aqui estão dois exemplos menores de programação com listas. 
    A função <span class="inlinecode"><span class="id" title="var">hd</span></span> retorna o primeiro elemento (a "cabeça") da lista,
    enquanto <span class="inlinecode"><span class="id" title="var">tl</span></span> retorna tudo exceto o primeiro elemento (a "cauda"). 
    Obviamente, a lista vazia não tem primeiro elemento, por isso, 
    devemos fornecer um valor padrão a ser retornado nesse caso. 
<div class="paragraph"> </div>

<a name="lab14"></a><h3 class="section">Cabeça (com default) e cauda</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd</span> (<span class="id" title="var">default</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">default</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tl</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">nil</span>  <br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd1</span>:             <span class="id" title="var">hd</span> 0 [1;2;3] = 1.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd2</span>:             <span class="id" title="var">hd</span> 0 [] = 0.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_tl</span>:              <span class="id" title="var">tl</span> [1;2;3] = [2;3].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h4 class="section">Exercício: ** (<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">list_funs</span></span> <span class="inlinecode"></span>)</h4>

<div class="paragraph"> </div>

 Complete as definições de <span class="inlinecode"><span class="id" title="var">nonzeros</span></span>, <span class="inlinecode"><span class="id" title="var">oddmembers</span></span> e
<span class="inlinecode"><span class="id" title="var">countoddmembers</span></span> abaixo. Dê uma olhada nos testes para entender o que
estas funções devem fazer. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nonzeros</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nonzeros</span>:            <span class="id" title="var">nonzeros</span> [0;1;0;2;3;0;0] = [1;2;3].<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">oddmembers</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_oddmembers</span>:            <span class="id" title="var">oddmembers</span> [0;1;0;2;3;0;0] = [1;3].<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">countoddmembers</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers1</span>:    <span class="id" title="var">countoddmembers</span> [1;0;3;1;4;5] = 4.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers2</span>:    <span class="id" title="var">countoddmembers</span> [0;2;4] = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers3</span>:    <span class="id" title="var">countoddmembers</span> <span class="id" title="var">nil</span> = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab16"></a><h4 class="section">Exercício: 3 stars, avançado (alternar)</h4>

<div class="paragraph"> </div>

 Complete a definição de <span class="inlinecode"><span class="id" title="var">alternate</span></span>, que "compacta" duas listas em uma só,
  alternando entre elementos retirados da primeira lista e elementos da segunda
  lista. Veja os testes abaixo para exemplos mais específicos.

<div class="paragraph"> </div>

    Note: uma maneira natural e elegante de escrever <span class="inlinecode"><span class="id" title="var">alternate</span></span> falhará em 
    satisfazer o requisito do Coq de que toda definição de <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>  
    "termina obviamente." Se você se encontra com esse problema, procure
    por uma solução levemente mais prolixa que considere elementos de ambas
    as listas ao mesmo tempo. (Uma solução possível requer definir o novo tipo 
    de par, mas esse não é a única solução. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">alternate</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate1</span>:        <span class="id" title="var">alternate</span> [1;2;3] [4;5;6] = [1;4;2;5;3;6].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate2</span>:        <span class="id" title="var">alternate</span> [1] [4;5;6] = [1;4;5;6].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate3</span>:        <span class="id" title="var">alternate</span> [1;2;3] [4] = [1;4;2;3].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate4</span>:        <span class="id" title="var">alternate</span> [] [20;30] = [20;30].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h2 class="section">Multiconjuntos com Listas</h2>

<div class="paragraph"> </div>

 Uma <span class="inlinecode"><span class="id" title="var">bag</span></span> (ou <span class="inlinecode"><span class="id" title="var">multiconjunto</span></span>) é como um conjunto, mas cada
    elemento pode aparecer múltiplas vezes, em vez de unicamente.  Uma 
    implementação razoável de multiconjuntos é representar um multiconjunto 
    de números através de uma lista. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bag</span> := <span class="id" title="var">natlist</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h4 class="section">Exercício: *** (bag_functions)</h4>

<div class="paragraph"> </div>

 Complete as definições para as funções
    <span class="inlinecode"><span class="id" title="var">count</span></span>, <span class="inlinecode"><span class="id" title="var">sum</span></span>, <span class="inlinecode"><span class="id" title="var">add</span></span>, e <span class="inlinecode"><span class="id" title="var">member</span></span> para multiconjuntos. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">count</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
</div>

<div class="doc">
Todas estas provas podem ser feitas usando apenas <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_count1</span>:              <span class="id" title="var">count</span> 1 [1;2;3;1;4;1] = 3.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_count2</span>:              <span class="id" title="var">count</span> 6 [1;2;3;1;4;1] = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
A função <span class="inlinecode"><span class="id" title="var">sum</span></span> para multiconjuntos é similar à função <span class="inlinecode"><span class="id" title="var">união</span></span> para
conjuntos: <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> contém todos os elementos de <span class="inlinecode"><span class="id" title="var">a</span></span> e
<span class="inlinecode"><span class="id" title="var">b</span></span>. (Geralmente os matemáticos definem <span class="inlinecode"><span class="id" title="var">union</span></span> em multiconjuntos de
forma um pouquinho diferente, por isto que não estamos usando o mesmo
nome para esta operação.)
Para a função <span class="inlinecode"><span class="id" title="var">sum</span></span> lhe daremos uma declaração que não determina
explicitamente os nomes dos argumentos. Além disso, é utilizada a
palavra-chave <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> ao invés de <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>. Então, mesmo que
você tivesse nome para os argumentos, não seria possível processá-los
recursivamente.
O motivo de declarar esta questão desta forma é encorajá-lo a pensar
se <span class="inlinecode"><span class="id" title="var">sum</span></span> pode ser implementado de uma maneira diferente -- talvez
através de funções que já foram definidas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">sum</span> : <span class="id" title="var">bag</span> → <span class="id" title="var">bag</span> → <span class="id" title="var">bag</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_sum1</span>:              <span class="id" title="var">count</span> 1 (<span class="id" title="var">sum</span> [1;2;3] [1;4;1]) = 3.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">add</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bag</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_add1</span>:                <span class="id" title="var">count</span> 1 (<span class="id" title="var">add</span> 1 [1;4;1]) = 3.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_add2</span>:                <span class="id" title="var">count</span> 5 (<span class="id" title="var">add</span> 1 [1;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">member</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bool</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_member1</span>:             <span class="id" title="var">member</span> 1 [1;4;1] = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_member2</span>:             <span class="id" title="var">member</span> 2 [1;4;1] = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab19"></a><h4 class="section">Exercício: ***, opcional (bag_more_functions)</h4>

<div class="paragraph"> </div>

 Aqui estão mais algumas funções de multiconjuntos com as quais você pode
praticar. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">remove_one</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bag</span> :=<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one1</span>:         <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;5;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one2</span>:         <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one3</span>:         <span class="id" title="var">count</span> 4 (<span class="id" title="var">remove_one</span> 5 [2;1;4;5;1;4]) = 2.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one4</span>:         <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;5;4;5;1;4]) = 1.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">remove_all</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bag</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all1</span>:          <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;5;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all2</span>:          <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all3</span>:          <span class="id" title="var">count</span> 4 (<span class="id" title="var">remove_all</span> 5 [2;1;4;5;1;4]) = 2.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all4</span>:          <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;5;4;5;1;4;5;1;4]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">subset</span> (<span class="id" title="var">s1</span>:<span class="id" title="var">bag</span>) (<span class="id" title="var">s2</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_subset1</span>:              <span class="id" title="var">subset</span> [1;2] [2;1;4;1] = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_subset2</span>:              <span class="id" title="var">subset</span> [1;2;2] [2;1;4;1] = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab20"></a><h4 class="section">Exercício: *** (bag_theorem)</h4>

<div class="paragraph"> </div>

 Escrever abaixo um teorema interessante, chamado <span class="inlinecode"><span class="id" title="var">bag_theorem</span></span>, sobre 
    multiconjuntos
    envolvendo as funções <span class="inlinecode"><span class="id" title="var">count</span></span> e <span class="inlinecode"><span class="id" title="var">add</span></span>, e provar o teorema.  Note que, uma
    vez que este problema é aberto, é possível imaginar um teorema
    que é verdadeiro, mas cuja prova requisite técnicas que você ainda
    não aprendeu.  Sinta-se livre para pedir ajuda se você ficar travado! 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab21"></a><h1 class="section">Raciocínio Sobre Listas</h1>

<div class="paragraph"> </div>

 Assim como os números, fatos simples sobre funções de 
    processamento de listas pode algumas vezes ser inteiramente provados
    por simplificação. Por exemplo, a simplificação realizada por <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> 
    é suficiente para este teorema... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">nil_app</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;[] ++ <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
... porque o <span class="inlinecode">[]</span> é substituído pela sua posição de casamento
    na definição de <span class="inlinecode"><span class="id" title="var">app</span></span>, permitindo que a própria correspondência 
    seja simplificada. 
<div class="paragraph"> </div>

 Algumas vezes, também é possível, assim como com números, realizar
análise por casos nas possíveis formas (vazia ou não-vazia) de uma lista
desconhecida. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">tl_length_pred</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pred</span> (<span class="id" title="var">length</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> (<span class="id" title="var">tl</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = cons n l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Aqui, o caso <span class="inlinecode"><span class="id" title="var">nil</span></span> funciona porque nós optamos por definir <span class="inlinecode"><span class="id" title="var">tl</span></span> <span class="inlinecode"><span class="id" title="var">nil</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">nil</span></span>.
Observe que a anotação <span class="inlinecode"><span class="id" title="keyword">as</span></span> na tática <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> introduz dois nomes, <span class="inlinecode"><span class="id" title="var">n</span></span>
e <span class="inlinecode"><span class="id" title="var">l&acute;</span></span>, o que corresponde ao fato de que o construtor <span class="inlinecode"><span class="id" title="var">cons</span></span> para listas tem
dois argumentos (a cabeça e a cauda da lista que está sendo construída). 
<div class="paragraph"> </div>

 Normalmente, porém, teoremas interessantes a respeito de listas requerem 
    indução para as suas provas. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab22"></a><h2 class="section">Micro-Sermão</h2>

<div class="paragraph"> </div>

 Simplesmente ler exemplos de transrição de prova não vai te levar muito 
    longe!
    É muito importante trabalhar os detalhes de cada uma das provas,
    quando usar o Coq e pensar sobre o que cada passo da prova realiza.  Senão,
    é mais ou menos garantido que os exercícios não farão
    sentido... 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h2 class="section">Indução sobre Listas</h2>

<div class="paragraph"> </div>

 Provas por indução em tipos de dados como <span class="inlinecode"><span class="id" title="var">natlist</span></span> são
    talvez um pouco menos familiar do que indução de número natural padrão, 
    mas o ideia base é igualmente simples.  Cada declaração de <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
    define um conjunto de valores de dados que pode ser contruídos
    a partir de construtores declarados: um booleano pode ou ser <span class="inlinecode"><span class="id" title="var">true</span></span> ou
    <span class="inlinecode"><span class="id" title="var">false</span></span>; um número pode ou ser <span class="inlinecode"><span class="id" title="var">O</span></span> ou <span class="inlinecode"><span class="id" title="var">S</span></span> aplicado a um número; uma
    lista pode ser ou <span class="inlinecode"><span class="id" title="var">nil</span></span> ou <span class="inlinecode"><span class="id" title="var">cons</span></span> aplicado a um número e a uma lista.

<div class="paragraph"> </div>

    Além disso, aplicações dos construtores declarados um para com o outro 
    são as _únicas formas possíveis que elementos de um conjunto 
    indutivamente definido pode ter, e este fato dá diretamente origem a 
    uma forma de raciocinar sobre conjuntos indutivamente definidos: um 
    número é <span class="inlinecode"><span class="id" title="var">O</span></span> ou então é <span class="inlinecode"><span class="id" title="var">S</span></span> aplicado a algum número <i>menor</i>; uma 
    lista é <span class="inlinecode"><span class="id" title="var">nil</span></span> ou então é <span class="inlinecode"><span class="id" title="var">cons</span></span> aplicada a um número e alguma lista 
    <i>menor</i>; etc. Então, se temos em mente alguma proposição <span class="inlinecode"><span class="id" title="var">P</span></span> que 
    menciona uma lista <span class="inlinecode"><span class="id" title="var">l</span></span> e queremos argumentar que <span class="inlinecode"><span class="id" title="var">P</span></span> é válida para 
    <i>todas</i> as listas, podemos raciocinar da seguinte forma:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Em primeiro lugar, mostrar que <span class="inlinecode"><span class="id" title="var">P</span></span> é verdade de <span class="inlinecode"><span class="id" title="var">l</span></span> quando 

</li>
</ul>
      <span class="inlinecode"><span class="id" title="var">l</span></span> é <span class="inlinecode"><span class="id" title="var">nil</span></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> Em seguida, mostrar que <span class="inlinecode"><span class="id" title="var">P</span></span> é verdade de <span class="inlinecode"><span class="id" title="var">l</span></span> quando <span class="inlinecode"><span class="id" title="var">l</span></span> é 

</li>
</ul>
      <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">&acute;</span> para algum número <span class="inlinecode"><span class="id" title="var">n</span></span> e alguma lista menor <span class="inlinecode"><span class="id" title="var">l&acute;</span></span>, 
      assumindo que <span class="inlinecode"><span class="id" title="var">P</span></span> é verdadeiro para <span class="inlinecode"><span class="id" title="var">l&acute;</span></span>.

<div class="paragraph"> </div>

Já que listas maiores só podem ser construídas a partir de listas
menores, chegando, em algum momento, em <span class="inlinecode"><span class="id" title="var">nil</span></span>, estas duas sentenças juntas
estabelecem a verdade de <span class="inlinecode"><span class="id" title="var">P</span></span> para todas as listas <span class="inlinecode"><span class="id" title="var">l</span></span>. Veja abaixo um
exemplo concreto: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <span class="id" title="var">natlist</span>, <br/>
&nbsp;&nbsp;(<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span> = <span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ <span class="id" title="var">l3</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l1&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = cons n l1'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl1&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Mais uma vez, esta prova Coq não é especialmente esclarecedora como um
documento estático escrito - é fácil entender o que está acontecendo se você
está lendo a prova em uma sessão Coq interativa e pode ver a meta atual
e o contexto em cada ponto, mas este estado não é visível nas partes registradas
da prova Coq. Assim, uma prova em linguagem natural -- escrita para leitores
humanos -- terá de incluir indicações mais explícitas; em particular, isto
ajudará o leitor a permanecer orientado se nós lembrarmos à ele o que exatamente
é a hipótese de indução no segundo caso. 
<div class="paragraph"> </div>

<a name="lab24"></a><h3 class="section">Versão Informal</h3>

<div class="paragraph"> </div>

 <i>Theorem</i>: For all lists <span class="inlinecode"><span class="id" title="var">l1</span></span>, <span class="inlinecode"><span class="id" title="var">l2</span></span>, and <span class="inlinecode"><span class="id" title="var">l3</span></span>, 
   <span class="inlinecode">(<span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">(<span class="id" title="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span>)</span>.

<div class="paragraph"> </div>

   <i>Prova</i>: Por indução sobre <span class="inlinecode"><span class="id" title="var">l1</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Primeiro, supomos que <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  Devemos provar que
       (<font size=-2>&#9744;</font> ++ l2) ++ l3 = <font size=-2>&#9744;</font> ++ (l2 ++ l3),
     o que segue diretamente da definição de  <span class="inlinecode">++</span>.

<div class="paragraph"> </div>


</li>
<li> Segundo, supomos que <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l1&acute;</span></span>, com
       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)
     (a hipótese de indução). Devemos mostrar que
       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

</li>
</ul>
]]  
     Por definição de <span class="inlinecode">++</span>, isto segue de 
       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),
     o que é uma consequência imediata da hipótese de indução.  <font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab25"></a><h3 class="section">Um Outro Exemplo</h3>

<div class="paragraph"> </div>

   Aqui está um exemplo similar para ser trabalhado em grupo em sala. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_length</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">length</span> <span class="id" title="var">l1</span>) + (<span class="id" title="var">length</span> <span class="id" title="var">l2</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l1&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = cons".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl1&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab26"></a><h3 class="section">Inversão de uma Lista</h3>

<div class="paragraph"> </div>

 Para um exemplo um pouco mais intricado de uma prova por indução
    sobre listas, supor que nós definimos uma função "cons na direita"
    <span class="inlinecode"><span class="id" title="var">snoc</span></span>, como a que segue... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">snoc</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ [<span class="id" title="var">v</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span> :: (<span class="id" title="var">snoc</span> <span class="id" title="var">t</span> <span class="id" title="var">v</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
... e use ele para definir uma função de inversão de lista <span class="inlinecode"><span class="id" title="var">rev</span></span>
    como segue: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">rev</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">snoc</span> (<span class="id" title="var">rev</span> <span class="id" title="var">t</span>) <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_rev1</span>:            <span class="id" title="var">rev</span> [1;2;3] = [3;2;1].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_rev2</span>:            <span class="id" title="var">rev</span> <span class="id" title="var">nil</span> = <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab27"></a><h3 class="section">Provas sobre inversão</h3>

<div class="paragraph"> </div>

 Agora vamos provar mais alguns teoremas sobre listas usando os nossos 
    recém-definidos <span class="inlinecode"><span class="id" title="var">snoc</span></span> e <span class="inlinecode"><span class="id" title="var">rev</span></span>. Para algo um pouco mais desafiador 
    do que as provas indutivas que temos visto até agora, vamos provar 
    que inverter uma lista não altera a sua extensão. Nossa primeira 
    tentativa nesta prova fica presa no caso sucessor ... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_length_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = []".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = n :: l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="var">simplifying</span>. *)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHl&acute;</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Agora, consideremos a equação sobre <span class="inlinecode"><span class="id" title="var">snoc</span></span> que teria nos permitido
progredir: vamos prová-la como um novo lema.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_snoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">snoc</span> <span class="id" title="var">l</span> <span class="id" title="var">n</span>) = <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = cons n' l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Observe que descrevemos o lema o mais <i>geral</i> possível: em particular,
quantificamos sobre <i>todas</i> as <span class="inlinecode"><span class="id" title="var">natlist</span></span>s, e não apenas aquelas que resultam da
aplicação de <span class="inlinecode"><span class="id" title="var">rev</span></span>. Isso deve parecer natural, porque está claro que
a veracidade da meta não depende da lista que foi invertida. Além disso, é muito
mais fácil provar a propriedade mais geral. 
<div class="paragraph"> </div>

 Agora nós podemos completar a prova original. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_length</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = cons".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">length_snoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Para comparação, aqui está uma prova informal de dois destes teoremas:

<div class="paragraph"> </div>

    <i>Teorema</i>: Para todo número <span class="inlinecode"><span class="id" title="var">n</span></span> e lista <span class="inlinecode"><span class="id" title="var">l</span></span>,
       <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">snoc</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span>.

<div class="paragraph"> </div>

    <i>Prova</i>: Por indução em <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Primeiramente, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  Nós devemos mostrar que
        length (snoc <font size=-2>&#9744;</font> n) = S (length <font size=-2>&#9744;</font>),
      o que segue diretamente das definições de
      <span class="inlinecode"><span class="id" title="var">length</span></span> e <span class="inlinecode"><span class="id" title="var">snoc</span></span>.

<div class="paragraph"> </div>


</li>
<li> Em seguida, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span>::<span class="id" title="var">l&acute;</span></span>, com
        length (snoc l' n) = S (length l').
      Nós devemos mostrar que
        length (snoc (n' :: l') n) = S (length (n' :: l')).
      Pela definição de <span class="inlinecode"><span class="id" title="var">length</span></span> e <span class="inlinecode"><span class="id" title="var">snoc</span></span>, isto prossegue de
        S (length (snoc l' n)) = S (S (length l')),

</li>
</ul>
]].
      Isto é uma consequência imediata da hipótese de indução. <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 <i>Teorema</i>: Para toda lista <span class="inlinecode"><span class="id" title="var">l</span></span>, <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

    <i>Prova</i>: Por indução em <span class="inlinecode"><span class="id" title="var">l</span></span>.  

<div class="paragraph"> </div>

<ul class="doclist">
<li> Primeiro, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  Nós devemos mostrar que
          length (rev <font size=-2>&#9744;</font>) = length <font size=-2>&#9744;</font>,
        o que segue diretamente para a definição de <span class="inlinecode"><span class="id" title="var">length</span></span> 
        e <span class="inlinecode"><span class="id" title="var">rev</span></span>.

<div class="paragraph"> </div>


</li>
<li> Em seguinda, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l&acute;</span></span>, com
          length (rev l') = length l'.
        Nós devemos mostrar que
          length (rev (n :: l')) = length (n :: l').
        Pela definição de <span class="inlinecode"><span class="id" title="var">rev</span></span>, isto segue para
          length (snoc (rev l') n) = S (length l')
        o que, pelo lema anterior, isso é o mesmo que
          S (length (rev l')) = S (length l').
        Isto é direto da hipótese de indução. <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

 Obviamente, o estilo dessas provas bastante detalhista
      e pedante.  Depois de algumas provas similares, 
      nós devemos achar mais fácil acompanhar provas que entram
      menos em detalhe (desde que nós possamos facilmente 
      acompanhar elas mentalmente ou rabiscando em um papel
      se necessário) e destacando apenas os os passos não óbvios.  
      Neste estilo mais comprimido, a prova acima pode parecer 
      como isto: 
<div class="paragraph"> </div>

 <i>Teorema</i>:
     Para todas as listas <span class="inlinecode"><span class="id" title="var">l</span></span>, <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

    <i>Prova</i>: primeiro, observe que
       length (snoc l n) = S (length l)
     para qualquer <span class="inlinecode"><span class="id" title="var">l</span></span>.  Isto segue através de uma indução sobre <span class="inlinecode"><span class="id" title="var">l</span></span>.
     A principal propriedade agora segue por outra simples indução sobre <span class="inlinecode"><span class="id" title="var">l</span></span>,
     usando a observação junto com a hipótese de indução no caso onde
     <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span>::<span class="id" title="var">l&acute;</span></span>. <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Qual estilo é preferível em uma determinada situação depende 
    da sofisticação do público esperado e de quão semelhante a prova em
    questão é com relação àquelas com as quais o público já está familiarizado. 
    O estilo mais rebuscado é um bom padrão para os propósitos presentes. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab28"></a><h2 class="section">O comando <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span></h2>

<div class="paragraph"> </div>

 Nós vimos que podemos usar teoremas já provados nas novas
provas, através de <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>, e posteriormente veremos outras formas
de reutilizar teoremas já definidos. Mas, para usar um teorema, devemos
saber seu nome, e relembrar o nome de todos os teoremas que poderíamos
usar pode ficar bastante difícil! Já é muitas vezes penoso lembrar
quais teoremas foram provados, sendo mais difícil ainda lembrar seus nomes.

<div class="paragraph"> </div>

O comando <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> do Coq é bastante útil nesse caso. Digitar <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span>
<span class="inlinecode"><span class="id" title="var">foo</span></span> fará com que Coq exiba uma lista de todos os teoremas que envolvem <span class="inlinecode"><span class="id" title="var">foo</span></span>.
Por exemplo, tente remover o seguinte comentário para ver uma lista dos
teoremas que provamos sobre <span class="inlinecode"><span class="id" title="var">rev</span></span>: 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Mantenha o <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> em mente enquanto você faz os seguintes 
    exercícios e ao longo do resto do curso; isso pode salvar você 
    muitas vezes! 
<div class="paragraph"> </div>

 Também, se você está usando ProofGeneral, você pode
    executar um comando <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> com <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span>. Você pode colar sua
    resposta em seu buffer com <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-;</span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab29"></a><h2 class="section">Lista de Exercícios, Parte 1</h2>

<div class="paragraph"> </div>

<a name="lab30"></a><h4 class="section">Exercício: *** (list_exercises)</h4>

<div class="paragraph"> </div>

 Mais prática com listas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_end</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> ++ [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_involutive</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Existe uma solução curta para o próximo exercício. Se você se encontrar 
    perdido, dê um passo para trás e tente buscar um caminho mais simples. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> <span class="id" title="var">l4</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ (<span class="id" title="var">l3</span> ++ <span class="id" title="var">l4</span>)) = ((<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span>) ++ <span class="id" title="var">l4</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">snoc_append</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">snoc</span> <span class="id" title="var">l</span> <span class="id" title="var">n</span> = <span class="id" title="var">l</span> ++ [<span class="id" title="var">n</span>].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">distr_rev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">rev</span> <span class="id" title="var">l2</span>) ++ (<span class="id" title="var">rev</span> <span class="id" title="var">l1</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Um exercício sobre sua implementação de <span class="inlinecode"><span class="id" title="var">nonzeros</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nonzeros_app</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">nonzeros</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">nonzeros</span> <span class="id" title="var">l1</span>) ++ (<span class="id" title="var">nonzeros</span> <span class="id" title="var">l2</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab31"></a><h4 class="section">Exercício: ** (beq_natlist)</h4>

<div class="paragraph"> </div>

 Complete a definição de <span class="inlinecode"><span class="id" title="var">beq_natlist</span></span>, que compara se listas de
números são iguais. Prove que <span class="inlinecode"><span class="id" title="var">beq_natlist</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> retorna <span class="inlinecode"><span class="id" title="var">true</span></span> para
toda lista <span class="inlinecode"><span class="id" title="var">l</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">beq_natlist</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_beq_natlist1</span> :   (<span class="id" title="var">beq_natlist</span> <span class="id" title="var">nil</span> <span class="id" title="var">nil</span> = <span class="id" title="var">true</span>).<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_beq_natlist2</span> :   <span class="id" title="var">beq_natlist</span> [1;2;3] [1;2;3] = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_beq_natlist3</span> :   <span class="id" title="var">beq_natlist</span> [1;2;3] [1;2;4] = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">beq_natlist_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">beq_natlist</span> <span class="id" title="var">l</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab32"></a><h2 class="section">Lista de Exercícios, Parte 2</h2>

<div class="paragraph"> </div>

<a name="lab33"></a><h4 class="section">Exercício: ** (list_design)</h4>

<div class="paragraph"> </div>

 Exercício de planejamento:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Escreva um teorema não trivial <span class="inlinecode"><span class="id" title="var">cons_snoc_app</span></span> envolvendo <span class="inlinecode"><span class="id" title="var">cons</span></span> (<span class="inlinecode">::</span>),

</li>
</ul>
     <span class="inlinecode"><span class="id" title="var">snoc</span></span>, e <span class="inlinecode"><span class="id" title="var">app</span></span> (<span class="inlinecode">++</span>).

<div class="paragraph"> </div>

<ul class="doclist">
<li> Prove-o. 
</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab34"></a><h4 class="section">Exercício: ***, avançado (bag_proofs)</h4>

<div class="paragraph"> </div>

 Aqui está alguns pequenos teoremas a provar a respeito das suas
    definições de conjuntos anteriormente nesse arquivo. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">count_member_nonzero</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">s</span> : <span class="id" title="var">bag</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">ble_nat</span> 1 (<span class="id" title="var">count</span> 1 (1 :: <span class="id" title="var">s</span>)) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
O lema a seguir sobre <span class="inlinecode"><span class="id" title="var">ble_nat</span></span> deve te ajudar na próxima prova. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ble_n_Sn</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ble_nat</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">remove_decreases_count</span>: <span class="id" title="keyword">∀</span> (<span class="id" title="var">s</span> : <span class="id" title="var">bag</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">ble_nat</span> (<span class="id" title="var">count</span> 0 (<span class="id" title="var">remove_one</span> 0 <span class="id" title="var">s</span>)) (<span class="id" title="var">count</span> 0 <span class="id" title="var">s</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab35"></a><h4 class="section">Exercício: ***, opcional (bag_count_sum)</h4>

<div class="paragraph"> </div>

 Escreve abaixo um teorema interessante <span class="inlinecode"><span class="id" title="var">bag_count_sum</span></span> sobre multiconjuntos
    envolvendo as funções <span class="inlinecode"><span class="id" title="var">count</span></span> e <span class="inlinecode"><span class="id" title="var">sum</span></span>, e prove.
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab36"></a><h4 class="section">Exercício: 4 stars, advanced (rev_injective)</h4>

<div class="paragraph"> </div>

 Prove que a função <span class="inlinecode"><span class="id" title="var">rev</span></span> é injetiva, ou seja,

<div class="paragraph"> </div>

    forall (l1 l2 : natlist), rev l1 = rev l2 -&gt; l1 = l2.

<div class="paragraph"> </div>

Há uma maneira simples e outra difícil de resolver este exercício.

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab37"></a><h1 class="section">Opções</h1>

<div class="paragraph"> </div>

 O tipo <span class="inlinecode"><span class="id" title="var">natoption</span></span> pode ser usado como uma forma de retornar
  "códigos de erro" de funções. Por exemplo, suponha que queiramos
  escrever uma função que retorne o <span class="inlinecode"><span class="id" title="var">n</span></span>-ésimo elemento de uma
  lista. Se seu tipo for <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">natlist</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, então a função terá
  que retornar algum número mesmo se o tamanho da lista for menor que <span class="inlinecode"><span class="id" title="var">n</span></span>! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">index_bad</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ 42  <br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l&acute;</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">beq_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">a</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">index_bad</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>) <span class="id" title="var">l&acute;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab38"></a><h3 class="section"> </h3>
 Por outro lado, se dermos à ela o tipo <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">natlist</span></span> <span class="inlinecode">→</span>  <span class="inlinecode"><span class="id" title="var">natoption</span></span>, então
poderemos retornar <span class="inlinecode"><span class="id" title="var">None</span></span> quando a lista for muito curta e um <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> quando
a lista tiver elementos suficientes e <span class="inlinecode"><span class="id" title="var">a</span></span> aparecer na posição <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natoption</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Some</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">natoption</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">None</span> : <span class="id" title="var">natoption</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">index</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">None</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l&acute;</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">beq_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">Some</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">index</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>) <span class="id" title="var">l&acute;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_index1</span> :    <span class="id" title="var">index</span> 0 [4;5;6;7]  = <span class="id" title="var">Some</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_index2</span> :    <span class="id" title="var">index</span> 3 [4;5;6;7]  = <span class="id" title="var">Some</span> 7.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_index3</span> :    <span class="id" title="var">index</span> 10 [4;5;6;7] = <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Esse éxemplo é também uma oportunidade para introduzir mais
    uma característica  da liguagem de programação Coq: expressões
    condicionais... 
<div class="paragraph"> </div>

<a name="lab39"></a><h3 class="section"> </h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">index&acute;</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">None</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l&acute;</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">beq_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Some</span> <span class="id" title="var">a</span> <span class="id" title="keyword">else</span> <span class="id" title="var">index&acute;</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>) <span class="id" title="var">l&acute;</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
As condicionais do Coq são exatamante como aquelas encontradas em qualquer
    outra linguaguem, com uma pequena generalização.  Uma vez que o Coq não
    define o tipo booleano, ele permite expressões condicionais sobre
    <i>qualquer</i> tipo indutivamente definido com exatamente dois construtores.  A
    condição é considerada verdadeira quando é avaliada para o primeiro
    construtor na definição de indução <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> e falsa se é avaliada para o
    segundo. 
<div class="paragraph"> </div>

 A função abaixo retira um <span class="inlinecode"><span class="id" title="var">nat</span></span> de <span class="inlinecode"><span class="id" title="var">natoption</span></span>, retornando
    um padrão fornecido no caso <span class="inlinecode"><span class="id" title="var">None</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">option_elim</span> (<span class="id" title="var">d</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">o</span> : <span class="id" title="var">natoption</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">o</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="var">n&acute;</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">None</span> ⇒ <span class="id" title="var">d</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab40"></a><h4 class="section">Exercício: ** (hd_opt)</h4>

<div class="paragraph"> </div>

 Usando a mesma ideia, ajuste a função <span class="inlinecode"><span class="id" title="var">hd</span></span> anterior para que não
    precisemos ter que passar um elemento padrão para o caso <span class="inlinecode"><span class="id" title="var">nil</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd_opt</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_opt1</span> : <span class="id" title="var">hd_opt</span> [] = <span class="id" title="var">None</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_opt2</span> : <span class="id" title="var">hd_opt</span> [1] = <span class="id" title="var">Some</span> 1.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_opt3</span> : <span class="id" title="var">hd_opt</span> [5;6] = <span class="id" title="var">Some</span> 5.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab41"></a><h4 class="section">Exercício: 1 star, opcional (option_elim_hd)</h4>

<div class="paragraph"> </div>

 Este exercício relaciona o seu novo <span class="inlinecode"><span class="id" title="var">hd_opt</span></span> com o velho <span class="inlinecode"><span class="id" title="var">hd</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">option_elim_hd</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">default</span>:<span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">hd</span> <span class="id" title="var">default</span> <span class="id" title="var">l</span> = <span class="id" title="var">option_elim</span> <span class="id" title="var">default</span> (<span class="id" title="var">hd_opt</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab42"></a><h1 class="section">Dicionários</h1>

<div class="paragraph"> </div>

 Como ilustração final de como as estruturas de dados fundamentais podem ser
definidas em Coq, aqui está a declaração de um tipo de dados <i>dicionário</i>
simples, chamado <span class="inlinecode"><span class="id" title="var">dictionary</span></span>, utilizando números tanto para as chaves quanto
para os valores armazenados nestas chaves. (Ou seja, um dicionário representa um
mapeamento finito de números para números.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Dictionary</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">dictionary</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">empty</span>  : <span class="id" title="var">dictionary</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">record</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="var">dictionary</span> → <span class="id" title="var">dictionary</span>.<br/>

<br/>
</div>

<div class="doc">
Essa declaração pode ser lida como: "Existem duas maneiras de construir
    um <span class="inlinecode"><span class="id" title="var">dictionary</span></span> (<i>dicionário</i>): ou usando o construtor <span class="inlinecode"><span class="id" title="var">empty</span></span> (<i>vazio</i>)
    para representar um dicionário vazio, ou aplicando o construtor <span class="inlinecode"><span class="id" title="var">record</span></span>
    (<i>gravar</i>) para uma chave, um valor, e um <span class="inlinecode"><span class="id" title="var">dictionary</span></span> existente para 
    construir um <span class="inlinecode"><span class="id" title="var">dictionary</span></span> com uma chave adicional para mapear valores." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">insert</span> (<span class="id" title="var">key</span> <span class="id" title="var">value</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) : <span class="id" title="var">dictionary</span> :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">record</span> <span class="id" title="var">key</span> <span class="id" title="var">value</span> <span class="id" title="var">d</span>).<br/>

<br/>
</div>

<div class="doc">
Aqui está a função <span class="inlinecode"><span class="id" title="var">find</span></span> (<i>encontrar</i>), que procura um <span class="inlinecode"><span class="id" title="var">dictionary</span></span>
    (<i>dicionário</i>) para a chave dada. Atribuindo <span class="inlinecode"><span class="id" title="var">None</span></span> (<i>nada</i>) se a chave não
    for encontrada e <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">val</span></span> (<i>algum valor</i>) se a chave for mapeada até
    <span class="inlinecode"><span class="id" title="var">val</span></span> no dicionário. Se a mesma chave for mapeada em múltiplos valores,
    <span class="inlinecode"><span class="id" title="var">find</span></span> irá retorar o primeiro que encontrar. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">find</span> (<span class="id" title="var">key</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) : <span class="id" title="var">natoption</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">empty</span>         ⇒ <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">record</span> <span class="id" title="var">k</span> <span class="id" title="var">v</span> <span class="id" title="var">d&acute;</span> ⇒ <span class="id" title="keyword">if</span> (<span class="id" title="var">beq_nat</span> <span class="id" title="var">key</span> <span class="id" title="var">k</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> (<span class="id" title="var">Some</span> <span class="id" title="var">v</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> (<span class="id" title="var">find</span> <span class="id" title="var">key</span> <span class="id" title="var">d&acute;</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab43"></a><h4 class="section">Exercício: * (dictionary_invariant1)</h4>

<div class="paragraph"> </div>

 Complete a prova seguinte. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">dictionary_invariant1&acute;</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) (<span class="id" title="var">k</span> <span class="id" title="var">v</span>: <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">find</span> <span class="id" title="var">k</span> (<span class="id" title="var">insert</span> <span class="id" title="var">k</span> <span class="id" title="var">v</span> <span class="id" title="var">d</span>)) = <span class="id" title="var">Some</span> <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab44"></a><h4 class="section">Exercício: * (dictionary_invariant2)</h4>

<div class="paragraph"> </div>

 Complete a seguinte prova. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">dictionary_invariant2&acute;</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) (<span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span>: <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">beq_nat</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> = <span class="id" title="var">false</span> → <span class="id" title="var">find</span> <span class="id" title="var">m</span> <span class="id" title="var">d</span> = <span class="id" title="var">find</span> <span class="id" title="var">m</span> (<span class="id" title="var">insert</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Dictionary</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatList</span>.<br/>

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>