<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Lists</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Lists</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Listas: Trabalhando com Dados Estruturados</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="keyword">Induction</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">NatList</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h1 class="section">Pares de Números</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> In an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> type definition, each constructor can take
    any number of arguments -- none (as with <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">O</span></span>), one (as
    with <span class="inlinecode"><span class="id" title="var">S</span></span>), or more than one, as in this definition: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natprod</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">pair</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="var">natprod</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> This declaration can be read: "There is just one way to
    construct a pair of numbers: by applying the constructor <span class="inlinecode"><span class="id" title="var">pair</span></span> to
    two arguments of type <span class="inlinecode"><span class="id" title="var">nat</span></span>." 
<div class="paragraph"> </div>

 Nós podemos construir um elemento de <span class="inlinecode"><span class="id" title="var">natprod</span></span> dessa maneira: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">pair</span> 3 5).<br/>

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Here are two simple function definitions for extracting the
    first and second components of a pair.  (The definitions also
    illustrate how to do pattern matching on two-argument
    constructors.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fst</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snd</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">fst</span> (<span class="id" title="var">pair</span> 3 5)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Since pairs are used quite a bit, it is nice to be able to
    write them with the standard mathematical notation <span class="inlinecode">(<span class="id" title="var">x</span>,<span class="id" title="var">y</span>)</span> instead
    of <span class="inlinecode"><span class="id" title="var">pair</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.  We can tell Coq to allow this with a <span class="inlinecode"><span class="id" title="keyword">Notation</span></span>
    declaration. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;( x , y )" := (<span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>

<br/>
</div>

<div class="doc">
A nova notação pode ser usada tanto em expressões quanto no
 casamento de padrões (de fato, nós ja vimos isto no capítulo anterior
 esta notação é disponibilizada pela biblioteca padrão): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> (<span class="id" title="var">fst</span> (3,5)).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fst&acute;</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snd&acute;</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">swap_pair</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>) : <span class="id" title="var">natprod</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" title="var">x</span>,<span class="id" title="var">y</span>) ⇒ (<span class="id" title="var">y</span>,<span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Let's try and prove a few simple facts about pairs.  If we
    state the lemmas in a particular (and slightly peculiar) way, we
    can prove them with just reflexivity (and its built-in
    simplification): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">surjective_pairing&acute;</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">n</span>,<span class="id" title="var">m</span>) = (<span class="id" title="var">fst</span> (<span class="id" title="var">n</span>,<span class="id" title="var">m</span>), <span class="id" title="var">snd</span> (<span class="id" title="var">n</span>,<span class="id" title="var">m</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> Note that <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> is not enough if we state the lemma in a
    more natural way: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">surjective_pairing_stuck</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">p</span> = (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>, <span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h3 class="section"> </h3>
 Nós temos que expor a estrutura de <span class="inlinecode"><span class="id" title="var">p</span></span>, de tal maneira que <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> 
    possa realizar o casamento de padrão em <span class="inlinecode"><span class="id" title="var">fst</span></span> e em <span class="inlinecode"><span class="id" title="var">snd</span></span>.  
    Nós podemos fazer isso através de <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>.

<div class="paragraph"> </div>

    <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Notice that, unlike for <span class="inlinecode"><span class="id" title="var">nat</span></span>s, <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> doesn't generate an
    extra subgoal here.  That's because <span class="inlinecode"><span class="id" title="var">natprod</span></span>s can only be
    constructed in one way.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">surjective_pairing</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">p</span> = (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>, <span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n</span> <span class="id" title="var">m</span>]. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h4 class="section">Exercício: * (<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">snd_fst_is_swap</span></span> <span class="inlinecode"></span>)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">snd_fst_is_swap</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">snd</span> <span class="id" title="var">p</span>, <span class="id" title="var">fst</span> <span class="id" title="var">p</span>) = <span class="id" title="var">swap_pair</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab8"></a><h4 class="section">Exercício: *, opcional (<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">fst_swap_is_snd</span></span> <span class="inlinecode"></span>)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">fst_swap_is_snd</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">p</span> : <span class="id" title="var">natprod</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">fst</span> (<span class="id" title="var">swap_pair</span> <span class="id" title="var">p</span>) = <span class="id" title="var">snd</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab9"></a><h1 class="section">Listas de Números</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Generalizing the definition of pairs a little, we can
    describe the type of <i>lists</i> of numbers like this: "A list is
    either the empty list or else a pair of a number and another
    list." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natlist</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> : <span class="id" title="var">natlist</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">cons</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">natlist</span> → <span class="id" title="var">natlist</span>.<br/>

<br/>
</div>

<div class="doc">
Por exemplo, se encontra abaixo uma lista de três elementos: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist</span> := <span class="id" title="var">cons</span> 1 (<span class="id" title="var">cons</span> 2 (<span class="id" title="var">cons</span> 3 <span class="id" title="var">nil</span>)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab10"></a><h3 class="section"> </h3>
 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> As with pairs, it is more convenient to write lists in
    familiar programming notation.  The following two declarations
    allow us to use <span class="inlinecode">::</span> as an infix <span class="inlinecode"><span class="id" title="var">cons</span></span> operator and square
    brackets as an "outfix" notation for constructing lists. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x :: l" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> <span class="id" title="var">l</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[ ]" := <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;[ x ; .. ; y ]" := (<span class="id" title="var">cons</span> <span class="id" title="var">x</span> .. (<span class="id" title="var">cons</span> <span class="id" title="var">y</span> <span class="id" title="var">nil</span>) ..).<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> It is not necessary to fully understand these declarations,
    but in case you are interested, here is roughly what's going on.

<div class="paragraph"> </div>

    A anotação <span class="inlinecode"><span class="id" title="tactic">right</span></span> <span class="inlinecode"><span class="id" title="keyword">associativity</span></span> (<i>associatividade à direita</i>) diz ao Coq
    como utilizar parênteses em expressões envolvendo o uso de muitos <span class="inlinecode">::</span>, 
    então, por exemplo, as três próximas declarações significam exatamente a mesma coisa: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist1</span> := 1 :: (2 :: (3 :: <span class="id" title="var">nil</span>)).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist2</span> := 1 :: 2 :: 3 :: <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mylist3</span> := [1;2;3].<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> The <span class="inlinecode"><span class="id" title="tactic">at</span></span> <span class="inlinecode"><span class="id" title="keyword">level</span></span> <span class="inlinecode">60</span> part tells Coq how to parenthesize
    expressions that involve both <span class="inlinecode">::</span> and some other infix operator.
    For example, since we defined <span class="inlinecode">+</span> as infix notation for the <span class="inlinecode"><span class="id" title="var">plus</span></span>
    function at level 50,
Notation "x + y" := (plus x y)  
                    (at level 50, left associativity).
   The <span class="inlinecode">+</span> operator will bind tighter than <span class="inlinecode">::</span>, so <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>
   will be parsed, as we'd expect, as <span class="inlinecode">(1</span> <span class="inlinecode">+</span> <span class="inlinecode">2)</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span> rather than <span class="inlinecode">1</span>
   <span class="inlinecode">+</span> <span class="inlinecode">(2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3])</span>.

<div class="paragraph"> </div>

   <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> (By the way, it's worth noting in passing that expressions like "<span class="inlinecode">1</span>
   <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">[3]</span>" can be a little confusing when you read them in a .v
   file.  The inner brackets, around 3, indicate a list, but the outer
   brackets, which are invisible in the HTML rendering, are there to
   instruct the "coqdoc" tool that the bracketed part should be
   displayed as Coq code rather than running text.)

<div class="paragraph"> </div>

A segunda e a terceira declaração de <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> acima introduzem a
 notação padrão de colchetes para listas; o lado direito da terceira
 declaração ilustra a sintaxe do Coq para declarar notações n-árias  e
 traduzi-las para sequências aninhadas de construtores binários. 
<div class="paragraph"> </div>

<a name="lab11"></a><h3 class="section">Repetição</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> A number of functions are useful for manipulating lists.
    For example, the <span class="inlinecode"><span class="id" title="tactic">repeat</span></span> function takes a number <span class="inlinecode"><span class="id" title="var">n</span></span> and a
    <span class="inlinecode"><span class="id" title="var">count</span></span> and returns a list of length <span class="inlinecode"><span class="id" title="var">count</span></span> where every element
    is <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="tactic">repeat</span> (<span class="id" title="var">n</span> <span class="id" title="var">count</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">count</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">count&acute;</span> ⇒ <span class="id" title="var">n</span> :: (<span class="id" title="tactic">repeat</span> <span class="id" title="var">n</span> <span class="id" title="var">count&acute;</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h3 class="section">Comprimento</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> The <span class="inlinecode"><span class="id" title="var">length</span></span> function calculates the length of a list. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">length</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h3 class="section">Concatenação</h3>
 A função <span class="inlinecode"><span class="id" title="var">app</span></span> "append" (<i>anexar</i>) concatena duas listas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">app</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ <span class="id" title="var">l2</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span> :: (<span class="id" title="var">app</span> <span class="id" title="var">t</span> <span class="id" title="var">l2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Actually, <span class="inlinecode"><span class="id" title="var">app</span></span> will be used a lot in some parts of what
    follows, so it is convenient to have an infix operator for it. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x ++ y" := (<span class="id" title="var">app</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app1</span>:             [1;2;3] ++ [4;5] = [1;2;3;4;5].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app2</span>:             <span class="id" title="var">nil</span> ++ [4;5] = [4;5].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_app3</span>:             [1;2;3] ++ <span class="id" title="var">nil</span> = [1;2;3].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Here are two smaller examples of programming with lists.
    The <span class="inlinecode"><span class="id" title="var">hd</span></span> function returns the first element (the "head") of the
    list, while <span class="inlinecode"><span class="id" title="var">tl</span></span> returns everything but the first
    element (the "tail").  
    Of course, the empty list has no first element, so we
    must pass a default value to be returned in that case.  
<div class="paragraph"> </div>

<a name="lab14"></a><h3 class="section">Cabeça (com default) e cauda</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd</span> (<span class="id" title="var">default</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">default</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tl</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">nil</span>  <br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd1</span>:             <span class="id" title="var">hd</span> 0 [1;2;3] = 1.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd2</span>:             <span class="id" title="var">hd</span> 0 [] = 0.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_tl</span>:              <span class="id" title="var">tl</span> [1;2;3] = [2;3].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h4 class="section">Exercício: ** (<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">list_funs</span></span> <span class="inlinecode"></span>)</h4>

<div class="paragraph"> </div>

 Complete as definições de <span class="inlinecode"><span class="id" title="var">nonzeros</span></span>, <span class="inlinecode"><span class="id" title="var">oddmembers</span></span> e
<span class="inlinecode"><span class="id" title="var">countoddmembers</span></span> abaixo. Dê uma olhada nos testes para entender o que
estas funções devem fazer. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nonzeros</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_nonzeros</span>:            <span class="id" title="var">nonzeros</span> [0;1;0;2;3;0;0] = [1;2;3].<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">oddmembers</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_oddmembers</span>:            <span class="id" title="var">oddmembers</span> [0;1;0;2;3;0;0] = [1;3].<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">countoddmembers</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers1</span>:    <span class="id" title="var">countoddmembers</span> [1;0;3;1;4;5] = 4.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers2</span>:    <span class="id" title="var">countoddmembers</span> [0;2;4] = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_countoddmembers3</span>:    <span class="id" title="var">countoddmembers</span> <span class="id" title="var">nil</span> = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab16"></a><h4 class="section">Exercício: 3 stars, avançado (alternar)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Complete the definition of <span class="inlinecode"><span class="id" title="var">alternate</span></span>, which "zips up" two
    lists into one, alternating between elements taken from the first list and
    elements from the second.  See the tests below for more specific examples.

<div class="paragraph"> </div>

    <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> Note: one natural and elegant way of writing <span class="inlinecode"><span class="id" title="var">alternate</span></span> will fail
    to satisfy Coq's requirement that all <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> definitions be "obviously
    terminating."  If you find yourself in this rut, look for a slightly more
    verbose solution that considers elements of both lists at the same time.
    (One possible solution requires defining a new kind of pairs, but this is
    not the only way.)  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">alternate</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate1</span>:        <span class="id" title="var">alternate</span> [1;2;3] [4;5;6] = [1;4;2;5;3;6].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate2</span>:        <span class="id" title="var">alternate</span> [1] [4;5;6] = [1;4;5;6].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate3</span>:        <span class="id" title="var">alternate</span> [1;2;3] [4] = [1;4;2;3].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_alternate4</span>:        <span class="id" title="var">alternate</span> [] [20;30] = [20;30].<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h2 class="section">Multiconjuntos com Listas</h2>

<div class="paragraph"> </div>

 Uma <span class="inlinecode"><span class="id" title="var">bag</span></span> (ou <span class="inlinecode"><span class="id" title="var">multiconjunto</span></span>) é como um conjunto, mas cada
    elemento pode aparecer múltiplas vezes, em vez de unicamente.  Uma 
    implementação razoável de multiconjuntos é representar um multiconjunto 
    de números através de uma lista. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bag</span> := <span class="id" title="var">natlist</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h4 class="section">Exercício: *** (bag_functions)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Complete the following definitions for the functions
    <span class="inlinecode"><span class="id" title="var">count</span></span>, <span class="inlinecode"><span class="id" title="var">sum</span></span>, <span class="inlinecode"><span class="id" title="var">add</span></span>, and <span class="inlinecode"><span class="id" title="var">member</span></span> for bags. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">count</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">nat</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> All these proofs can be done just by <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_count1</span>:              <span class="id" title="var">count</span> 1 [1;2;3;1;4;1] = 3.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_count2</span>:              <span class="id" title="var">count</span> 6 [1;2;3;1;4;1] = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
A função <span class="inlinecode"><span class="id" title="var">sum</span></span> para multiconjuntos é similar à função <span class="inlinecode"><span class="id" title="var">união</span></span> para
conjuntos: <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> contém todos os elementos de <span class="inlinecode"><span class="id" title="var">a</span></span> e
<span class="inlinecode"><span class="id" title="var">b</span></span>. (Geralmente os matemáticos definem <span class="inlinecode"><span class="id" title="var">union</span></span> em multiconjuntos de
forma um pouquinho diferente, por isto que não estamos usando o mesmo
nome para esta operação.)
Para a função <span class="inlinecode"><span class="id" title="var">sum</span></span> lhe daremos uma declaração que não determina
explicitamente os nomes dos argumentos. Além disso, é utilizada a
palavra-chave <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> ao invés de <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>. Então, mesmo que
você tivesse nome para os argumentos, não seria possível processá-los
recursivamente.
O motivo de declarar esta questão desta forma é encorajá-lo a pensar
se <span class="inlinecode"><span class="id" title="var">sum</span></span> pode ser implementado de uma maneira diferente -- talvez
através de funções que já foram definidas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">sum</span> : <span class="id" title="var">bag</span> → <span class="id" title="var">bag</span> → <span class="id" title="var">bag</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_sum1</span>:              <span class="id" title="var">count</span> 1 (<span class="id" title="var">sum</span> [1;2;3] [1;4;1]) = 3.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">add</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bag</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_add1</span>:                <span class="id" title="var">count</span> 1 (<span class="id" title="var">add</span> 1 [1;4;1]) = 3.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_add2</span>:                <span class="id" title="var">count</span> 5 (<span class="id" title="var">add</span> 1 [1;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">member</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bool</span> := <br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_member1</span>:             <span class="id" title="var">member</span> 1 [1;4;1] = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_member2</span>:             <span class="id" title="var">member</span> 2 [1;4;1] = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab19"></a><h4 class="section">Exercício: ***, opcional (bag_more_functions)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Here are some more bag functions for you to practice with. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">remove_one</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bag</span> :=<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one1</span>:         <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;5;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one2</span>:         <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one3</span>:         <span class="id" title="var">count</span> 4 (<span class="id" title="var">remove_one</span> 5 [2;1;4;5;1;4]) = 2.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_one4</span>:         <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_one</span> 5 [2;1;5;4;5;1;4]) = 1.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">remove_all</span> (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">s</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bag</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all1</span>:          <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;5;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all2</span>:          <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;4;1]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all3</span>:          <span class="id" title="var">count</span> 4 (<span class="id" title="var">remove_all</span> 5 [2;1;4;5;1;4]) = 2.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_remove_all4</span>:          <span class="id" title="var">count</span> 5 (<span class="id" title="var">remove_all</span> 5 [2;1;5;4;5;1;4;5;1;4]) = 0.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">subset</span> (<span class="id" title="var">s1</span>:<span class="id" title="var">bag</span>) (<span class="id" title="var">s2</span>:<span class="id" title="var">bag</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_subset1</span>:              <span class="id" title="var">subset</span> [1;2] [2;1;4;1] = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_subset2</span>:              <span class="id" title="var">subset</span> [1;2;2] [2;1;4;1] = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab20"></a><h4 class="section">Exercício: *** (bag_theorem)</h4>

<div class="paragraph"> </div>

 Escrever abaixo um teorema interessante, chamado <span class="inlinecode"><span class="id" title="var">bag_theorem</span></span>, sobre 
    multiconjuntos
    envolvendo as funções <span class="inlinecode"><span class="id" title="var">count</span></span> e <span class="inlinecode"><span class="id" title="var">add</span></span>, e provar o teorema.  Note que, uma
    vez que este problema é aberto, é possível imaginar um teorema
    que é verdadeiro, mas cuja prova requisite técnicas que você ainda
    não aprendeu.  Sinta-se livre para pedir ajuda se você ficar travado! 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab21"></a><h1 class="section">Raciocínio Sobre Listas</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Just as with numbers, simple facts about list-processing
    functions can sometimes be proved entirely by simplification. For
    example, the simplification performed by <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> is enough
    for this theorem... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">nil_app</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;[] ++ <span class="id" title="var">l</span> = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> ... because the <span class="inlinecode">[]</span> is substituted into the match position
    in the definition of <span class="inlinecode"><span class="id" title="var">app</span></span>, allowing the match itself to be
    simplified. 
<div class="paragraph"> </div>

 Algumas vezes, também é possível, assim como com números, realizar
análise por casos nas possíveis formas (vazia ou não-vazia) de uma lista
desconhecida. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">tl_length_pred</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pred</span> (<span class="id" title="var">length</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> (<span class="id" title="var">tl</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = cons n l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Here, the <span class="inlinecode"><span class="id" title="var">nil</span></span> case works because we've chosen to define
    <span class="inlinecode"><span class="id" title="var">tl</span></span> <span class="inlinecode"><span class="id" title="var">nil</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">nil</span></span>. Notice that the <span class="inlinecode"><span class="id" title="keyword">as</span></span> annotation on the <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>
    tactic here introduces two names, <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">l&acute;</span></span>, corresponding to
    the fact that the <span class="inlinecode"><span class="id" title="var">cons</span></span> constructor for lists takes two
    arguments (the head and tail of the list it is constructing). 
<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> Usually, though, interesting theorems about lists require
    induction for their proofs. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab22"></a><h2 class="section">Micro-Sermão</h2>

<div class="paragraph"> </div>

 Simplesmente ler exemplos de transrição de prova não vai te levar muito 
    longe!
    É muito importante trabalhar os detalhes de cada uma das provas,
    quando usar o Coq e pensar sobre o que cada passo da prova realiza.  Senão,
    é mais ou menos garantido que os exercícios não farão
    sentido... 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab23"></a><h2 class="section">Indução sobre Listas</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Proofs by induction over datatypes like <span class="inlinecode"><span class="id" title="var">natlist</span></span> are
    perhaps a little less familiar than standard natural number
    induction, but the basic idea is equally simple.  Each <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>
    declaration defines a set of data values that can be built up from
    the declared constructors: a boolean can be either <span class="inlinecode"><span class="id" title="var">true</span></span> or
    <span class="inlinecode"><span class="id" title="var">false</span></span>; a number can be either <span class="inlinecode"><span class="id" title="var">O</span></span> or <span class="inlinecode"><span class="id" title="var">S</span></span> applied to a number; a
    list can be either <span class="inlinecode"><span class="id" title="var">nil</span></span> or <span class="inlinecode"><span class="id" title="var">cons</span></span> applied to a number and a list.

<div class="paragraph"> </div>

    <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Moreover, applications of the declared constructors to one another
    are the <i>only</i> possible shapes that elements of an inductively
    defined set can have, and this fact directly gives rise to a way
    of reasoning about inductively defined sets: a number is either
    <span class="inlinecode"><span class="id" title="var">O</span></span> or else it is <span class="inlinecode"><span class="id" title="var">S</span></span> applied to some <i>smaller</i> number; a list is
    either <span class="inlinecode"><span class="id" title="var">nil</span></span> or else it is <span class="inlinecode"><span class="id" title="var">cons</span></span> applied to some number and some
    <i>smaller</i> list; etc. So, if we have in mind some proposition <span class="inlinecode"><span class="id" title="var">P</span></span>
    that mentions a list <span class="inlinecode"><span class="id" title="var">l</span></span> and we want to argue that <span class="inlinecode"><span class="id" title="var">P</span></span> holds for
    <i>all</i> lists, we can reason as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, show that <span class="inlinecode"><span class="id" title="var">P</span></span> is true of <span class="inlinecode"><span class="id" title="var">l</span></span> when <span class="inlinecode"><span class="id" title="var">l</span></span> is <span class="inlinecode"><span class="id" title="var">nil</span></span>.

<div class="paragraph"> </div>


</li>
<li> Then show that <span class="inlinecode"><span class="id" title="var">P</span></span> is true of <span class="inlinecode"><span class="id" title="var">l</span></span> when <span class="inlinecode"><span class="id" title="var">l</span></span> is <span class="inlinecode"><span class="id" title="var">cons</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">l&acute;</span></span> for
        some number <span class="inlinecode"><span class="id" title="var">n</span></span> and some smaller list <span class="inlinecode"><span class="id" title="var">l&acute;</span></span>, assuming that <span class="inlinecode"><span class="id" title="var">P</span></span>
        is true for <span class="inlinecode"><span class="id" title="var">l&acute;</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

Já que listas maiores só podem ser construídas a partir de listas
menores, chegando, em algum momento, em <span class="inlinecode"><span class="id" title="var">nil</span></span>, estas duas sentenças juntas
estabelecem a verdade de <span class="inlinecode"><span class="id" title="var">P</span></span> para todas as listas <span class="inlinecode"><span class="id" title="var">l</span></span>. Veja abaixo um
exemplo concreto: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> : <span class="id" title="var">natlist</span>, <br/>
&nbsp;&nbsp;(<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span> = <span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ <span class="id" title="var">l3</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l1&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = cons n l1'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl1&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Again, this Coq proof is not especially illuminating as a
    static written document -- it is easy to see what's going on if
    you are reading the proof in an interactive Coq session and you
    can see the current goal and context at each point, but this state
    is not visible in the written-down parts of the Coq proof.  So a
    natural-language proof -- one written for human readers -- will
    need to include more explicit signposts; in particular, it will
    help the reader stay oriented if we remind them exactly what the
    induction hypothesis is in the second case.  
<div class="paragraph"> </div>

<a name="lab24"></a><h3 class="section">Versão Informal</h3>

<div class="paragraph"> </div>

 <i>Theorem</i>: For all lists <span class="inlinecode"><span class="id" title="var">l1</span></span>, <span class="inlinecode"><span class="id" title="var">l2</span></span>, and <span class="inlinecode"><span class="id" title="var">l3</span></span>, 
   <span class="inlinecode">(<span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">(<span class="id" title="var">l2</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">l3</span>)</span>.

<div class="paragraph"> </div>

   <i>Prova</i>: Por indução sobre <span class="inlinecode"><span class="id" title="var">l1</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Primeiro, supomos que <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  Devemos provar que
       (<font size=-2>&#9744;</font> ++ l2) ++ l3 = <font size=-2>&#9744;</font> ++ (l2 ++ l3),
     o que segue diretamente da definição de  <span class="inlinecode">++</span>.

<div class="paragraph"> </div>


</li>
<li> Segundo, supomos que <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l1&acute;</span></span>, com
       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)
     (a hipótese de indução). Devemos mostrar que
       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3).

</li>
</ul>
]]  
     Por definição de <span class="inlinecode">++</span>, isto segue de 
       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3)),
     o que é uma consequência imediata da hipótese de indução.  <font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab25"></a><h3 class="section">Um Outro Exemplo</h3>

<div class="paragraph"> </div>

  <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> Here is a similar example to be worked together in class: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_length</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">length</span> <span class="id" title="var">l1</span>) + (<span class="id" title="var">length</span> <span class="id" title="var">l2</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l1</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l1&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l1 = cons".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl1&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab26"></a><h3 class="section">Inversão de uma Lista</h3>

<div class="paragraph"> </div>

 Para um exemplo um pouco mais intricado de uma prova por indução
    sobre listas, supor que nós definimos uma função "cons na direita"
    <span class="inlinecode"><span class="id" title="var">snoc</span></span>, como a que segue... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">snoc</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">v</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ [<span class="id" title="var">v</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">h</span> :: (<span class="id" title="var">snoc</span> <span class="id" title="var">t</span> <span class="id" title="var">v</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> ... and use it to define a list-reversing function <span class="inlinecode"><span class="id" title="var">rev</span></span>
    like this: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">rev</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natlist</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span>    ⇒ <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">t</span> ⇒ <span class="id" title="var">snoc</span> (<span class="id" title="var">rev</span> <span class="id" title="var">t</span>) <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_rev1</span>:            <span class="id" title="var">rev</span> [1;2;3] = [3;2;1].<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_rev2</span>:            <span class="id" title="var">rev</span> <span class="id" title="var">nil</span> = <span class="id" title="var">nil</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab27"></a><h3 class="section">Provas sobre inversão</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Now let's prove some more list theorems using our newly
    defined <span class="inlinecode"><span class="id" title="var">snoc</span></span> and <span class="inlinecode"><span class="id" title="var">rev</span></span>.  For something a little more challenging
    than the inductive proofs we've seen so far, let's prove that
    reversing a list does not change its length.  Our first attempt at
    this proof gets stuck in the successor case... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_length_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = []".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = n :: l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="var">simplifying</span>. *)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHl&acute;</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Agora, consideremos a equação sobre <span class="inlinecode"><span class="id" title="var">snoc</span></span> que teria nos permitido
progredir: vamos prová-la como um novo lema.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_snoc</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">snoc</span> <span class="id" title="var">l</span> <span class="id" title="var">n</span>) = <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = cons n' l'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
    <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Note that we make the lemma as <i>general</i> as possible: in 
    particular,
    we quantify over <i>all</i> <span class="inlinecode"><span class="id" title="var">natlist</span></span>s, not just those that result
    from an application of <span class="inlinecode"><span class="id" title="var">rev</span></span>. This should seem natural, 
    because the truth of the goal clearly doesn't depend on 
    the list having been reversed.  Moreover, it is much easier
    to prove the more general property. 

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> Now we can complete the original proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_length</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">length</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">l&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = nil".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "l = cons".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">length_snoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHl&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Para comparação, aqui está uma prova informal de dois destes teoremas:

<div class="paragraph"> </div>

    <i>Teorema</i>: Para todo número <span class="inlinecode"><span class="id" title="var">n</span></span> e lista <span class="inlinecode"><span class="id" title="var">l</span></span>,
       <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">snoc</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span>.

<div class="paragraph"> </div>

    <i>Prova</i>: Por indução em <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Primeiramente, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  Nós devemos mostrar que
        length (snoc <font size=-2>&#9744;</font> n) = S (length <font size=-2>&#9744;</font>),
      o que segue diretamente das definições de
      <span class="inlinecode"><span class="id" title="var">length</span></span> e <span class="inlinecode"><span class="id" title="var">snoc</span></span>.

<div class="paragraph"> </div>


</li>
<li> Em seguida, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span>::<span class="id" title="var">l&acute;</span></span>, com
        length (snoc l' n) = S (length l').
      Nós devemos mostrar que
        length (snoc (n' :: l') n) = S (length (n' :: l')).
      Pela definição de <span class="inlinecode"><span class="id" title="var">length</span></span> e <span class="inlinecode"><span class="id" title="var">snoc</span></span>, isto prossegue de
        S (length (snoc l' n)) = S (S (length l')),

</li>
</ul>
]].
      Isto é uma consequência imediata da hipótese de indução. <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 <i>Teorema</i>: Para toda lista <span class="inlinecode"><span class="id" title="var">l</span></span>, <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

    <i>Prova</i>: Por indução em <span class="inlinecode"><span class="id" title="var">l</span></span>.  

<div class="paragraph"> </div>

<ul class="doclist">
<li> Primeiro, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  Nós devemos mostrar que
          length (rev <font size=-2>&#9744;</font>) = length <font size=-2>&#9744;</font>,
        o que segue diretamente para a definição de <span class="inlinecode"><span class="id" title="var">length</span></span> 
        e <span class="inlinecode"><span class="id" title="var">rev</span></span>.

<div class="paragraph"> </div>


</li>
<li> Em seguinda, suponhamos que <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>::<span class="id" title="var">l&acute;</span></span>, com
          length (rev l') = length l'.
        Nós devemos mostrar que
          length (rev (n :: l')) = length (n :: l').
        Pela definição de <span class="inlinecode"><span class="id" title="var">rev</span></span>, isto segue para
          length (snoc (rev l') n) = S (length l')
        o que, pelo lema anterior, isso é o mesmo que
          S (length (rev l')) = S (length l').
        Isto é direto da hipótese de indução. <font size=-2>&#9744;</font> 
</li>
</ul>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Obviously, the style of these proofs is rather longwinded
    and pedantic.  After the first few, we might find it easier to
    follow proofs that give fewer details (since we can easily work
    them out in our own minds or on scratch paper if necessary) and
    just highlight the non-obvious steps.  In this more compressed
    style, the above proof might look more like this: 
<div class="paragraph"> </div>

 <i>Theorem</i>:
     For all lists <span class="inlinecode"><span class="id" title="var">l</span></span>, <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">rev</span></span> <span class="inlinecode"><span class="id" title="var">l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

    <i>Proof</i>: First, observe that
       length (snoc l n) = S (length l)
     for any <span class="inlinecode"><span class="id" title="var">l</span></span>.  This follows by a straightforward induction on <span class="inlinecode"><span class="id" title="var">l</span></span>.
     The main property now follows by another straightforward
     induction on <span class="inlinecode"><span class="id" title="var">l</span></span>, using the observation together with the
     induction hypothesis in the case where <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n&acute;</span>::<span class="id" title="var">l&acute;</span></span>. <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Which style is preferable in a given situation depends on
    the sophistication of the expected audience and on how similar the
    proof at hand is to ones that the audience will already be
    familiar with.  The more pedantic style is a good default for
    present purposes. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab28"></a><h2 class="section">O comando <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span></h2>

<div class="paragraph"> </div>

 Nós vimos que podemos usar teoremas já provados nas novas
provas, através de <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>, e posteriormente veremos outras formas
de reutilizar teoremas já definidos. Mas, para usar um teorema, devemos
saber seu nome, e relembrar o nome de todos os teoremas que poderíamos
usar pode ficar bastante difícil! Já é muitas vezes penoso lembrar
quais teoremas foram provados, sendo mais difícil ainda lembrar seus nomes.

<div class="paragraph"> </div>

    <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Coq's <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> command is quite helpful with this.  Typing
    <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> <span class="inlinecode"><span class="id" title="var">foo</span></span> will cause Coq to display a list of all theorems
    involving <span class="inlinecode"><span class="id" title="var">foo</span></span>.  For example, try uncommenting the following to
    see a list of theorems that we have proved about <span class="inlinecode"><span class="id" title="var">rev</span></span>: 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> Keep <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> in mind as you do the following exercises and
    throughout the rest of the course; it can save you a lot of time! 
<div class="paragraph"> </div>

 Também, se você está usando ProofGeneral, você pode
    executar um comando <span class="inlinecode"><span class="id" title="keyword">SearchAbout</span></span> com <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">a</span></span>. Você pode colar sua
    resposta em seu buffer com <span class="inlinecode"><span class="id" title="var">C</span>-<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">C</span>-;</span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab29"></a><h2 class="section">Lista de Exercícios, Parte 1</h2>

<div class="paragraph"> </div>

<a name="lab30"></a><h4 class="section">Exercício: *** (list_exercises)</h4>

<div class="paragraph"> </div>

 Mais prática com listas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_end</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">l</span> ++ [] = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">rev_involutive</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">rev</span> <span class="id" title="var">l</span>) = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> There is a short solution to the next exercise.  If you find
    yourself getting tangled up, step back and try to look for a
    simpler way. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> <span class="id" title="var">l3</span> <span class="id" title="var">l4</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">l1</span> ++ (<span class="id" title="var">l2</span> ++ (<span class="id" title="var">l3</span> ++ <span class="id" title="var">l4</span>)) = ((<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) ++ <span class="id" title="var">l3</span>) ++ <span class="id" title="var">l4</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">snoc_append</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">snoc</span> <span class="id" title="var">l</span> <span class="id" title="var">n</span> = <span class="id" title="var">l</span> ++ [<span class="id" title="var">n</span>].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">distr_rev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">rev</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">rev</span> <span class="id" title="var">l2</span>) ++ (<span class="id" title="var">rev</span> <span class="id" title="var">l1</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> An exercise about your implementation of <span class="inlinecode"><span class="id" title="var">nonzeros</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">nonzeros_app</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">nonzeros</span> (<span class="id" title="var">l1</span> ++ <span class="id" title="var">l2</span>) = (<span class="id" title="var">nonzeros</span> <span class="id" title="var">l1</span>) ++ (<span class="id" title="var">nonzeros</span> <span class="id" title="var">l2</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab31"></a><h4 class="section">Exercício: ** (beq_natlist)</h4>

<div class="paragraph"> </div>

 Complete a definição de <span class="inlinecode"><span class="id" title="var">beq_natlist</span></span>, que compara se listas de
números são iguais. Prove que <span class="inlinecode"><span class="id" title="var">beq_natlist</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> retorna <span class="inlinecode"><span class="id" title="var">true</span></span> para
toda lista <span class="inlinecode"><span class="id" title="var">l</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">beq_natlist</span> (<span class="id" title="var">l1</span> <span class="id" title="var">l2</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_beq_natlist1</span> :   (<span class="id" title="var">beq_natlist</span> <span class="id" title="var">nil</span> <span class="id" title="var">nil</span> = <span class="id" title="var">true</span>).<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_beq_natlist2</span> :   <span class="id" title="var">beq_natlist</span> [1;2;3] [1;2;3] = <span class="id" title="var">true</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_beq_natlist3</span> :   <span class="id" title="var">beq_natlist</span> [1;2;3] [1;2;4] = <span class="id" title="var">false</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">beq_natlist_refl</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">beq_natlist</span> <span class="id" title="var">l</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab32"></a><h2 class="section">Lista de Exercícios, Parte 2</h2>

<div class="paragraph"> </div>

<a name="lab33"></a><h4 class="section">Exercício: ** (list_design)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> Design exercise: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> Write down a non-trivial theorem <span class="inlinecode"><span class="id" title="var">cons_snoc_app</span></span>
       involving <span class="inlinecode"><span class="id" title="var">cons</span></span> (<span class="inlinecode">::</span>), <span class="inlinecode"><span class="id" title="var">snoc</span></span>, and <span class="inlinecode"><span class="id" title="var">app</span></span> (<span class="inlinecode">++</span>).  

</li>
<li> Prove it. 
</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab34"></a><h4 class="section">Exercício: ***, avançado (bag_proofs)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> Here are a couple of little theorems to prove about your
    definitions about bags earlier in the file. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">count_member_nonzero</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">s</span> : <span class="id" title="var">bag</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">ble_nat</span> 1 (<span class="id" title="var">count</span> 1 (1 :: <span class="id" title="var">s</span>)) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
O lema a seguir sobre <span class="inlinecode"><span class="id" title="var">ble_nat</span></span> deve te ajudar na próxima prova. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ble_n_Sn</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ble_nat</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n&acute;</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "0".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Case</span> "S n'".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn&acute;</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">remove_decreases_count</span>: <span class="id" title="keyword">∀</span> (<span class="id" title="var">s</span> : <span class="id" title="var">bag</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">ble_nat</span> (<span class="id" title="var">count</span> 0 (<span class="id" title="var">remove_one</span> 0 <span class="id" title="var">s</span>)) (<span class="id" title="var">count</span> 0 <span class="id" title="var">s</span>) = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab35"></a><h4 class="section">Exercício: ***, opcional (bag_count_sum)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Write down an interesting theorem <span class="inlinecode"><span class="id" title="var">bag_count_sum</span></span> about bags 
    involving the functions <span class="inlinecode"><span class="id" title="var">count</span></span> and <span class="inlinecode"><span class="id" title="var">sum</span></span>, and prove it.
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab36"></a><h4 class="section">Exercício: 4 stars, advanced (rev_injective)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Prove that the <span class="inlinecode"><span class="id" title="var">rev</span></span> function is injective, that is,

<div class="paragraph"> </div>

    forall (l1 l2 : natlist), rev l1 = rev l2 -&gt; l1 = l2.

<div class="paragraph"> </div>

There is a hard way and an easy way to solve this exercise.

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab37"></a><h1 class="section">Opções</h1>

<div class="paragraph"> </div>

 O tipo <span class="inlinecode"><span class="id" title="var">natoption</span></span> pode ser usado como uma forma de retornar
  "códigos de erro" de funções. Por exemplo, suponha que queiramos
  escrever uma função que retorne o <span class="inlinecode"><span class="id" title="var">n</span></span>-ésimo elemento de uma
  lista. Se seu tipo for <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">natlist</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, então a função terá
  que retornar algum número mesmo se o tamanho da lista for menor que <span class="inlinecode"><span class="id" title="var">n</span></span>! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">index_bad</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ 42  <br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l&acute;</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">beq_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">a</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">index_bad</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>) <span class="id" title="var">l&acute;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab38"></a><h3 class="section"> </h3>
 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> On the other hand, if we give it type <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">natlist</span></span> <span class="inlinecode">→</span>
    <span class="inlinecode"><span class="id" title="var">natoption</span></span>, then we can return <span class="inlinecode"><span class="id" title="var">None</span></span> when the list is too short
    and <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> when the list has enough members and <span class="inlinecode"><span class="id" title="var">a</span></span> appears at
    position <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natoption</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Some</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">natoption</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">None</span> : <span class="id" title="var">natoption</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">index</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">None</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l&acute;</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">beq_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> ⇒ <span class="id" title="var">Some</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> ⇒ <span class="id" title="var">index</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>) <span class="id" title="var">l&acute;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_index1</span> :    <span class="id" title="var">index</span> 0 [4;5;6;7]  = <span class="id" title="var">Some</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_index2</span> :    <span class="id" title="var">index</span> 3 [4;5;6;7]  = <span class="id" title="var">Some</span> 7.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_index3</span> :    <span class="id" title="var">index</span> 10 [4;5;6;7] = <span class="id" title="var">None</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> This example is also an opportunity to introduce one more
    small feature of Coq's programming language: conditional
    expressions... 
<div class="paragraph"> </div>

<a name="lab39"></a><h3 class="section"> </h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">index&acute;</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nil</span> ⇒ <span class="id" title="var">None</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">l&acute;</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">beq_nat</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Some</span> <span class="id" title="var">a</span> <span class="id" title="keyword">else</span> <span class="id" title="var">index&acute;</span> (<span class="id" title="var">pred</span> <span class="id" title="var">n</span>) <span class="id" title="var">l&acute;</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
As condicionais do Coq são exatamante como aquelas encontradas em qualquer
    outra linguaguem, com uma pequena generalização.  Uma vez que o Coq não
    define o tipo booleano, ele permite expressões condicionais sobre
    <i>qualquer</i> tipo indutivamente definido com exatamente dois construtores.  A
    condição é considerada verdadeira quando é avaliada para o primeiro
    construtor na definição de indução <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> e falsa se é avaliada para o
    segundo. 
<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> The function below pulls the <span class="inlinecode"><span class="id" title="var">nat</span></span> out of a <span class="inlinecode"><span class="id" title="var">natoption</span></span>, returning
    a supplied default in the <span class="inlinecode"><span class="id" title="var">None</span></span> case. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">option_elim</span> (<span class="id" title="var">d</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">o</span> : <span class="id" title="var">natoption</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">o</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">n&acute;</span> ⇒ <span class="id" title="var">n&acute;</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">None</span> ⇒ <span class="id" title="var">d</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab40"></a><h4 class="section">Exercício: ** (hd_opt)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Using the same idea, fix the <span class="inlinecode"><span class="id" title="var">hd</span></span> function from earlier so we don't
   have to pass a default element for the <span class="inlinecode"><span class="id" title="var">nil</span></span> case.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd_opt</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>) : <span class="id" title="var">natoption</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_opt1</span> : <span class="id" title="var">hd_opt</span> [] = <span class="id" title="var">None</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_opt2</span> : <span class="id" title="var">hd_opt</span> [1] = <span class="id" title="var">Some</span> 1.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">test_hd_opt3</span> : <span class="id" title="var">hd_opt</span> [5;6] = <span class="id" title="var">Some</span> 5.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab41"></a><h4 class="section">Exercício: 1 star, opcional (option_elim_hd)</h4>

<div class="paragraph"> </div>

 Este exercício relaciona o seu novo <span class="inlinecode"><span class="id" title="var">hd_opt</span></span> com o velho <span class="inlinecode"><span class="id" title="var">hd</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">option_elim_hd</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">l</span>:<span class="id" title="var">natlist</span>) (<span class="id" title="var">default</span>:<span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">hd</span> <span class="id" title="var">default</span> <span class="id" title="var">l</span> = <span class="id" title="var">option_elim</span> <span class="id" title="var">default</span> (<span class="id" title="var">hd_opt</span> <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab42"></a><h1 class="section">Dicionários</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Claudia</span></span> <span class="inlinecode"></span> As a final illustration of how fundamental data structures
    can be defined in Coq, here is the declaration of a simple
    <span class="inlinecode"><span class="id" title="var">dictionary</span></span> data type, using numbers for both the keys and the
    values stored under these keys.  (That is, a dictionary represents
    a finite map from numbers to numbers.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">Dictionary</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">dictionary</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">empty</span>  : <span class="id" title="var">dictionary</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">record</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="var">dictionary</span> → <span class="id" title="var">dictionary</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Dalay</span></span> <span class="inlinecode"></span> This declaration can be read: "There are two ways to construct a
    <span class="inlinecode"><span class="id" title="var">dictionary</span></span>: either using the constructor <span class="inlinecode"><span class="id" title="var">empty</span></span> to represent an
    empty dictionary, or by applying the constructor <span class="inlinecode"><span class="id" title="var">record</span></span> to
    a key, a value, and an existing <span class="inlinecode"><span class="id" title="var">dictionary</span></span> to construct a
    <span class="inlinecode"><span class="id" title="var">dictionary</span></span> with an additional key to value mapping." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">insert</span> (<span class="id" title="var">key</span> <span class="id" title="var">value</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) : <span class="id" title="var">dictionary</span> :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">record</span> <span class="id" title="var">key</span> <span class="id" title="var">value</span> <span class="id" title="var">d</span>).<br/>

<br/>
</div>

<div class="doc">
Aqui está a função <span class="inlinecode"><span class="id" title="var">find</span></span> (<i>encontrar</i>), que procura um <span class="inlinecode"><span class="id" title="var">dictionary</span></span>
    (<i>dicionário</i>) para a chave dada. Atribuindo <span class="inlinecode"><span class="id" title="var">None</span></span> (<i>nada</i>) se a chave não
    for encontrada e <span class="inlinecode"><span class="id" title="var">Some</span></span> <span class="inlinecode"><span class="id" title="var">val</span></span> (<i>algum valor</i>) se a chave for mapeada até
    <span class="inlinecode"><span class="id" title="var">val</span></span> no dicionário. Se a mesma chave for mapeada em múltiplos valores,
    <span class="inlinecode"><span class="id" title="var">find</span></span> irá retorar o primeiro que encontrar. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">find</span> (<span class="id" title="var">key</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) : <span class="id" title="var">natoption</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">d</span> <span class="id" title="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">empty</span>         ⇒ <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">record</span> <span class="id" title="var">k</span> <span class="id" title="var">v</span> <span class="id" title="var">d&acute;</span> ⇒ <span class="id" title="keyword">if</span> (<span class="id" title="var">beq_nat</span> <span class="id" title="var">key</span> <span class="id" title="var">k</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> (<span class="id" title="var">Some</span> <span class="id" title="var">v</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> (<span class="id" title="var">find</span> <span class="id" title="var">key</span> <span class="id" title="var">d&acute;</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab43"></a><h4 class="section">Exercício: * (dictionary_invariant1)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Francisco</span></span> <span class="inlinecode"></span> Complete the following proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">dictionary_invariant1&acute;</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) (<span class="id" title="var">k</span> <span class="id" title="var">v</span>: <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;(<span class="id" title="var">find</span> <span class="id" title="var">k</span> (<span class="id" title="var">insert</span> <span class="id" title="var">k</span> <span class="id" title="var">v</span> <span class="id" title="var">d</span>)) = <span class="id" title="var">Some</span> <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab44"></a><h4 class="section">Exercício: * (dictionary_invariant2)</h4>

<div class="paragraph"> </div>

 <span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">Renan</span></span> <span class="inlinecode"></span> Complete the following proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">dictionary_invariant2&acute;</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">d</span> : <span class="id" title="var">dictionary</span>) (<span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span>: <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">beq_nat</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> = <span class="id" title="var">false</span> → <span class="id" title="var">find</span> <span class="id" title="var">m</span> <span class="id" title="var">d</span> = <span class="id" title="var">find</span> <span class="id" title="var">m</span> (<span class="id" title="var">insert</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Dictionary</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">NatList</span>.<br/>

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>