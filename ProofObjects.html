<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>ProofObjects</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">ProofObjects</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">ProofObjects: Trabalhando Explicitamente com Evidência em Coq</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">MoreLogic</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Nos vimos que Coq possui mecanismos tanto para <i>programar</i>,
    utilizando tipos de dados indutivos (como <span class="inlinecode"><span class="id" title="var">nat</span></span> e <span class="inlinecode"><span class="id" title="var">list</span></span>) e
    funções sobre esses tipos, e para <i>provar  propriedades destes
    programas utilizando proposições indutivas (como <span class="inlinecode"><span class="id" title="var">ev</span></span> e <span class="inlinecode"><span class="id" title="var">eq</span></span>),
    implicação, e quantificação universal. Até agora, tratamos estes
    mecanismos como se fossem separados; para muitos propósitos esta
    é uma boa abordagem. Mas também encontramos indícios de que as
    facilidades de programação e de prova em Coq são estreitamente
    relacionados. Por exemplo, a palavra-chave <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> é usada
    tanto para declarar tipos de dados e proposições, e <span class="inlinecode">→</span> é utilizado
    ao mesmo tempo para enunciar o tipo das funções e para a implicação
    lógica. Isto não é um mero acaso! De fato, programas e provas em Coq
    são quase a mesma coisa. Neste capítulo, estudaremos os mecanismos
    desta similaridade.

<div class="paragraph"> </div>

    Já fomos confrontados com a ideia fundamental que demonstrabilidade é
    representada em Coq por <i>evidência  concreta. Quando nós construímos
    a demonstração de uma proposição básic, nós elaboramos de fato uma
    árvore de evidência, a qual pode ser enxergada como uma estrutura de
    dados. Se a proposição for uma implicação, como <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, então a
    evidência será um <i>transformador</i> de evidência: uma receita para 
    elaborar uma evidência para <span class="inlinecode"><span class="id" title="var">B</span></span> a partir de uma evidência para <span class="inlinecode"><span class="id" title="var">A</span></span>.
    Essencialmente, provas são simplesmente programas que manipulam
    evidência.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    Q. Se evidência for um dado, o que são as proposições?

<div class="paragraph"> </div>

    A. Elas são tipos!

<div class="paragraph"> </div>

    Veja novamente a definição formal da propriedade <span class="inlinecode"><span class="id" title="var">beautiful</span></span>.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">beautiful</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 O truque é pronunciar "<span class="inlinecode">:</span>" de forma diferente. Ao invés de "tem tipo",
    podemos dizer "é uma demonstração de". Por exemplo, a segunda linha da
    definição de <span class="inlinecode"><span class="id" title="var">beautiful</span></span> afirma que <span class="inlinecode"><span class="id" title="var">b_0</span>:</span> <span class="inlinecode"><span class="id" title="var">beautiful_0</span></span>. Assim, ao invés de
    "<span class="inlinecode"><span class="id" title="var">b_0</span></span> tem tipo <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode">0</span>", podemos ler "<span class="inlinecode"><span class="id" title="var">b_0</span></span> é uma demonstração de
    <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode">0</span>", e similarmente para <span class="inlinecode"><span class="id" title="var">b_3</span></span> e <span class="inlinecode"><span class="id" title="var">b_5</span></span>. 
<div class="paragraph"> </div>

<a name="lab3"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Esse jogo de palavras entre tipos e proposições (entre <span class="inlinecode">:</span> como "tem tipo"
    e <span class="inlinecode">:</span> como "é uma demonstração de" ou "constitui evidência para") é 
    chamado a <i>correspondência de Curry-Howard". Ele evidencia uma conexão
    fundamental entre o mundo da lógica e o mundo da computação.
<pre>
                 proposições   ~  tipos
                 demonstrações ~  valores
</pre>
    Desta conexão decorrem vários discernimentos úteis. Para começar, 
    ela proporciona uma interpretação natual do tipo do construtor <span class="inlinecode"><span class="id" title="var">b_sum</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">b_sum</span>.<br/>
</div>

<div class="doc">
Pode ser ido como "<span class="inlinecode"><span class="id" title="var">b_sum</span></span> é um construtor com quatro arguments -- 
    dois números <span class="inlinecode"><span class="id" title="var">n</span></span> e <span class="inlinecode"><span class="id" title="var">m</span></span>, e duas demonstrações, para as proposições
    <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> e <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>, respectivamente -- e produz uma
    demonstraçào para a proposição <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>+<span class="id" title="var">m</span>).&quot;</span> <span class="inlinecode"></span>
<div class="paragraph"> </div>

 Agora, vamos revisitar uma demonstração anterior envolvendo <span class="inlinecode"><span class="id" title="var">beautiful</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eight_is_beautiful</span>: <span class="id" title="var">beautiful</span> 8.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_sum</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span> := 3) (<span class="id" title="var">m</span> := 5).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_5</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Da mesma forma que para valores e funções ordinários, podemos executar
    o comando <span class="inlinecode"><span class="id" title="keyword">Print</span></span> para ver o  objeto demonstrador  que resulta da 
    transcrição desta demonstração. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eight_is_beautiful</span>.<br/>

<br/>
</div>

<div class="doc">
Tendo isto em vista, poderiamos indagar se nós mesmos podemos escrever tal
    expressão. De fato, isto é possível: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="var">b_sum</span> 3 5 <span class="id" title="var">b_3</span> <span class="id" title="var">b_5</span>).<br/>

<br/>
</div>

<div class="doc">
A expressão <span class="inlinecode"><span class="id" title="var">b_sum</span></span> <span class="inlinecode">3</span> <span class="inlinecode">5</span> <span class="inlinecode"><span class="id" title="var">b_3</span></span> <span class="inlinecode"><span class="id" title="var">b_5</span></span> pode ser interpretada como a a aplicação
    <span class="inlinecode"><span class="id" title="var">b_sum</span></span> com seus parâmetros sendo instanciados com os argumentos específicos
    <span class="inlinecode">3</span>, <span class="inlinecode">5</span> e os objetos de demonstração para as suas premissas, a saber
    <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode">3</span> e <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode">5</span> (Coq é programado para determinar que
    3+5=8). De forma alternativa, podemos interpretar <span class="inlinecode"><span class="id" title="var">b_sum</span></span> como um
    "construtor de evidência" primitivo que, quando a aplicado a dois
    números específicos, precisa ainda ser aplicado à evidência que estes
    números são <span class="inlinecode"><span class="id" title="var">beautiful</span></span>. Seu tipo, a saber
    <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span>,</span> <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>+<span class="id" title="var">m</span>)</span>,
    expressar esta funcionalidade, da mesma forma que o tipo polimórfico
    <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">X</span>,</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> visto anteriormente, expressa o fato que o
    construtor <span class="inlinecode"><span class="id" title="var">nil</span></span> pode ser interpretado como uma função que vai dos
    tipos para as listas vazias com elementos daqueles tipos. 
<div class="paragraph"> </div>

 Logo, temos uma forma alternativa de escrever uma demonstração do que
    <span class="inlinecode">8</span> é <span class="inlinecode"><span class="id" title="var">beautiful</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eight_is_beautiful&acute;</span>: <span class="id" title="var">beautiful</span> 8.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">b_sum</span> 3 5 <span class="id" title="var">b_3</span> <span class="id" title="var">b_5</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Repare que estamos aqui usando <span class="inlinecode"><span class="id" title="tactic">apply</span></span> de uma nova maneira: ao invés de
    somente fornecer o <i>nome  de uma hipótese ou de um teorema demonstrador
    anteriormente, cujo tipo corresponde à meta atual, estamos fornecendo uma
    <i>expressão  que constroi diretamente evidência do tipo necessário. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h1 class="section">Transcrição de Demonstrações e Objetos de Demonstrações</h1>

<div class="paragraph"> </div>

 Esses objetos de demonstrações fazem parte do cerne do funcionamento do Coq.

<div class="paragraph"> </div>

    Quando Coq segue uma transcrição de demonstração, o que acontece
    internamente é que um objeto demonstrador vem sendo construído aos poucos
 um termo cujo tipo é a proposição sendo demonstrada.  As táticas entre o
    comando <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> e o término <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> indicam ao Coq como construir um termo do
    tipo requerido. Para ver este processo em ação, vamos utilizar o comando
    <span class="inlinecode"><span class="id" title="keyword">Show</span></span> <span class="inlinecode"><span class="id" title="keyword">Proof</span></span> para exibir o estado atual da árvore de demonstração em vários
    pontos da demonstração por táticas que segue. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eight_is_beautiful&acute;&acute;</span>: <span class="id" title="var">beautiful</span> 8.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_sum</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span>:=3) (<span class="id" title="var">m</span>:=5).<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_3</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_5</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
A cada etapa, Coq construiu um termo com "buracos" (indicados por <span class="inlinecode">?1</span>,
    <span class="inlinecode">?2</span>, e assim sucessivamente), e também sabe qual tipo de elemento de
    evidência é necessário para preencher cada buraco. 
<div class="paragraph"> </div>

 Cada buraco corresponde a uma submeta, e a demonstração é concluída quando
    não há mais submetas. Neste ponto, o comando <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> associa um nome com a
    evidência que construimos e armazena esta associação no contexto global. 
<div class="paragraph"> </div>

 Demonstrações por táticas são úteis e convenientes, porém não essenciais: em
    princípio, podemos sempre construir manualmente a evidência necessária como
    mostrado anteriormente. Podemos então utilizar <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> (ao invés de
    <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span>) para dar um nome global diretamente ao uma evidência. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eight_is_beautiful&acute;&acute;&acute;</span> : <span class="id" title="var">beautiful</span> 8 :=<br/>
&nbsp;&nbsp;<span class="id" title="var">b_sum</span> 3 5 <span class="id" title="var">b_3</span> <span class="id" title="var">b_5</span>.<br/>

<br/>
</div>

<div class="doc">
Todas essas maneiras diferentes de construir uma demonstração levam 
    a salvar exatametne a mesma evidência no contexto global. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eight_is_beautiful</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eight_is_beautiful&acute;</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eight_is_beautiful&acute;&acute;</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">eight_is_beautiful&acute;&acute;&acute;</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab5"></a><h4 class="section">Exercício: nível 1 (six_is_beautiful)</h4>
 Dar uma demonstração por tática e um objeto demonstrador
    comprovando que <span class="inlinecode">6</span> é <span class="inlinecode"><span class="id" title="var">beautiful</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">six_is_beautiful</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">beautiful</span> 6.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">six_is_beautiful&acute;</span> : <span class="id" title="var">beautiful</span> 6 :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab6"></a><h4 class="section">Exercício: nível 1 (nine_is_beautiful)</h4>
 Dar uma demonstração por tática e um objeto demonstrador
    comprovando que <span class="inlinecode">9</span> é <span class="inlinecode"><span class="id" title="var">beautiful</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">nine_is_beautiful</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">beautiful</span> 9.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nine_is_beautiful&acute;</span> : <span class="id" title="var">beautiful</span> 9 :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h1 class="section">Quantificação, Implicações e Funções</h1>

<div class="paragraph"> </div>

 No universo computacional do Coq (onde ficamos principalmente até este
    capítulo), há duas famílias de valores com setas em seus tipos:
    <i>constructors  introduzido em tipos definidos indutivamente (através de
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>), e funções.

<div class="paragraph"> </div>

    Similarmente, no universo lógico de Coq, há duas maneiras de prover
    evidência para uma implicação: construtores introduzidos por proposições
    definidas indutivamente (através de <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>), e... funções!

<div class="paragraph"> </div>

    Por exemplo, considere esta afirmação: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">b_plus3</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span> → <span class="id" title="var">beautiful</span> (3+<span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_sum</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">b_3</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Qual é o objeto demonstrador correspondente a <span class="inlinecode"><span class="id" title="var">b_plus3</span></span>? 

<div class="paragraph"> </div>

    Estamos procurando uma expressão cujo <i>tipo  é <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span>
    <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode">(3+<span class="id" title="var">n</span>)</span> -- isto é, uma <i>função</i> que tem dois argumentos (um número
    e um elemento de evidência e retorna um elemento de evidência!  Eis ela: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">b_plus3&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span> → <span class="id" title="var">beautiful</span> (3+<span class="id" title="var">n</span>) := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) ⇒ <span class="id" title="keyword">fun</span> (<span class="id" title="var">H</span> : <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">b_sum</span> 3 <span class="id" title="var">n</span> <span class="id" title="var">b_3</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">b_plus3&acute;</span>.<br/>

<br/>
</div>

<div class="doc">
Lembre que <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">blah</span></span> significa "a função que, dado <span class="inlinecode"><span class="id" title="var">n</span></span>, retorna
    <span class="inlinecode"><span class="id" title="var">blah</span></span>."  Uma outra forma, equivalente, de escrever esta definição é: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">b_plus3&acute;&acute;</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span>) : <span class="id" title="var">beautiful</span> (3+<span class="id" title="var">n</span>) := <br/>
&nbsp;&nbsp;<span class="id" title="var">b_sum</span> 3 <span class="id" title="var">n</span> <span class="id" title="var">b_3</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">b_plus3&acute;&acute;</span>.<br/>

<br/>
</div>

<div class="doc">
Quando enxergamos a proposição sendo provada por <span class="inlinecode"><span class="id" title="var">b_plus3</span></span> como um tipo
    função, um dos seus aspectos pode parecer um pouco inusitado.  O tipo do
    segundo argumento é <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, e inclui o <i>valor</i> do primeiro argumento
    <span class="inlinecode"><span class="id" title="var">n</span></span>. Embora tais <i>tipos dependentes  não se encontram normalmente em
    linguagens de programação, mesmo linguagens funcionais como ML e Haskell,
    eles poderiam ser úteis nelas também.

<div class="paragraph"> </div>

    Observe que tanto a implicação (<span class="inlinecode">→</span>) quanto a quantificação (<span class="inlinecode"><span class="id" title="keyword">∀</span></span>)
    correspondem a funções sobre evidência. De fato, são essencialmente a
    mesma coisa: <span class="inlinecode">→</span> é apenas um atalho para um uso degenerado de
    <span class="inlinecode"><span class="id" title="keyword">∀</span></span> onde não há dependência, ou seja, não é necessário dar um nome
    ao tipo no lado esquerdo da seta. 
<div class="paragraph"> </div>

 Por exemplo, considere a proposição seguinte: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">beautiful_plus3</span> : <span class="id" title="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="keyword">∀</span> (<span class="id" title="var">E</span> : <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span>), <span class="id" title="var">beautiful</span> (<span class="id" title="var">n</span>+3).<br/>

<br/>
</div>

<div class="doc">
Um termo de demonstração habitando esta proposição seria uma função com dois
    argumentos: <span class="inlinecode"><span class="id" title="var">n</span></span>, um número, e <span class="inlinecode"><span class="id" title="var">E</span></span>, uma evidência que <span class="inlinecode"><span class="id" title="var">n</span></span> é <span class="inlinecode"><span class="id" title="var">beautiful</span></span>.
    Mas o nome <span class="inlinecode"><span class="id" title="var">E</span></span> para esta evidência não é usado no resto da afirmação, portanto
    é um bobo se dar o trabalho de lhe dar um nome. Nós poderiamos ter escrito
    assim, utilizando o identificador coringa <span class="inlinecode"><span class="id" title="var">_</span></span> ao invés de um verdadeiro nome: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">beautiful_plus3&acute;</span> : <span class="id" title="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="keyword">∀</span> (<span class="id" title="var">_</span> : <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span>), <span class="id" title="var">beautiful</span> (<span class="id" title="var">n</span>+3).<br/>

<br/>
</div>

<div class="doc">
Ou, de forma equivalente, podemos escrever em uma notação mais comun: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">beatiful_plus3&acute;&acute;</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span> → <span class="id" title="var">beautiful</span> (<span class="id" title="var">n</span>+3).<br/>

<br/>
</div>

<div class="doc">
Em geral, "<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>" é apenas açúcar sintático para "<span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode">(<span class="id" title="var">_</span>:<span class="id" title="var">P</span>),</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>". 
<div class="paragraph"> </div>

<a name="lab8"></a><h4 class="section">Exercício: nível 2 b_times2</h4>

<div class="paragraph"> </div>

 Fornecer um objeto demonstrador correspondente ao teorema <span class="inlinecode"><span class="id" title="var">b_times2</span></span> oriundo de Prop.v 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">b_times2&acute;</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span> → <span class="id" title="var">beautiful</span> (2*<span class="id" title="var">n</span>) :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab9"></a><h4 class="section">Exercise: nível 2, opcional (gorgeous_plus13_po)</h4>
 Elaborar um objeto demonstrativo correspondente ao teorema <span class="inlinecode"><span class="id" title="var">gorgeous_plus13</span></span> oriundo de Prop.v 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">gorgeous_plus13_po</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">gorgeous</span> <span class="id" title="var">n</span> → <span class="id" title="var">gorgeous</span> (13+<span class="id" title="var">n</span>):=<br/>
&nbsp;&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 É bastante revelador acompanhar os objetos demonstrativos 
    envolvendo os conectores lógics que definimos com proposições
    indutivas em Logic.v. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">and_example</span> : <br/>
&nbsp;&nbsp;(<span class="id" title="var">beautiful</span> 0) ∧ (<span class="id" title="var">beautiful</span> 3).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">conj</span>.<br/>
 <span class="id" title="tactic">apply</span> <span class="id" title="var">b_0</span>.<br/>
 <span class="id" title="tactic">apply</span> <span class="id" title="var">b_3</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Vamos dar uma olhada ao objeto demonstrativo deste teorema. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">and_example</span>.<br/>

<br/>
</div>

<div class="doc">
Note que a demonstração tem a forma
    conj (beautiful 0) (beautiful 3) 
         (...dem de beautiful 3...) (...dem de beautiful 3...)
    como esperado, dado o tipo de <span class="inlinecode"><span class="id" title="var">conj</span></span>. 
<div class="paragraph"> </div>

<a name="lab10"></a><h4 class="section">Exercício: nível 1, opcional (case_proof_objects)</h4>
 As táticas <span class="inlinecode"><span class="id" title="var">Case</span></span> foram comentadas na demonstração de <span class="inlinecode"><span class="id" title="var">and_example</span></span>
    para evitar de bagunçar o objeto demonstrativo. Como que você acha
    que o objeto demonstrativo parecerá se tiramos essas táticas dos
    comentários? Tente e veja por você mesmo.  <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">and_commut</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> : <span class="id" title="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> → <span class="id" title="var">Q</span> ∧ <span class="id" title="var">P</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">HP</span> <span class="id" title="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
 <span class="id" title="tactic">apply</span> <span class="id" title="var">HQ</span>.<br/>
 <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Novamente, comentamos as táticas <span class="inlinecode"><span class="id" title="var">Case</span></span> para facilitar a leitura do objeto
    demonstrador desse teorema. Ainda é um pouco complicado, mas após
    efetuar alguns passos de redução, podemos ver que tudo que está acontecendo
    é desmontar um registro contendo evidência para <span class="inlinecode"><span class="id" title="var">P</span></span> e para <span class="inlinecode"><span class="id" title="var">Q</span></span> e remontar
    ele na ordem oposta: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">and_commut</span>.<br/>

<br/>
</div>

<div class="doc">
Após reduzir as aplicações diretas de expressões <span class="inlinecode"><span class="id" title="keyword">fun</span></span> aos seus
    argumentos, obtemos: 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab11"></a><h4 class="section">Exercício: nível 2, opcional (conj_fact)</h4>
 Construir um objeto demonstrador para a proposição seguinte. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">conj_fact</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>, <span class="id" title="var">P</span> ∧ <span class="id" title="var">Q</span> → <span class="id" title="var">Q</span> ∧ <span class="id" title="var">R</span> → <span class="id" title="var">P</span> ∧ <span class="id" title="var">R</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab12"></a><h4 class="section">Exercício: nível 2, avançado, opcional (beautiful_iff_gorgeous)</h4>

<div class="paragraph"> </div>

 Nós mostramos que as famílias de proposições <span class="inlinecode"><span class="id" title="var">beautiful</span></span> e <span class="inlinecode"><span class="id" title="var">gorgeous</span></span>
    caracterizam o mesmo conjunto de números.  Demonstrar que <span class="inlinecode"><span class="id" title="var">beautiful</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">↔</span>
    <span class="inlinecode"><span class="id" title="var">gorgeous</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> para todo <span class="inlinecode"><span class="id" title="var">n</span></span>.  Como desafio, escrever a demonstração como um
    objeto demonstrativo, ao invés de usar táticas. (<i>Dica : caso você use
    teoremas já definidos, você só deve necessitar de uma única linha!) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">beautiful_iff_gorgeous</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">beautiful</span> <span class="id" title="var">n</span> ↔ <span class="id" title="var">gorgeous</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp; <span class="id" title="var">admit</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab13"></a><h4 class="section">Exercício: nível 2, opcional (or_commut'')</h4>
 Escrever um objeto demonstrador para <span class="inlinecode"><span class="id" title="var">or_commut</span></span> (sem utilizar <span class="inlinecode"><span class="id" title="keyword">Print</span></span>
    para espiar aqueles que já definimos!) 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Lembre que modelamos uma propriedade existencial como um par composto por
    um valor testemunho e por uma demonstração que o testemunho satisfaz a
    propriedade. Podemos escolher de construir a prova explicitamente.

<div class="paragraph"> </div>

    Por exemplo, considere esta proposição existencialmente quantificada: 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="var">ex</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">some_nat_is_even</span> : <span class="id" title="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" title="var">ex</span> <span class="id" title="var">_</span> <span class="id" title="var">ev</span>.<br/>

<br/>
</div>

<div class="doc">
Para demonstrar esta proposição, precisamos escolher um número em particular
    como testemunho -- digamos, 4 -- e prover a evidência que este número é
    <span class="inlinecode"><span class="id" title="var">even</span></span> (par). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snie</span> : <span class="id" title="var">some_nat_is_even</span> := <br/>
&nbsp;&nbsp;<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">ev</span> 4 (<span class="id" title="var">ev_SS</span> 2 (<span class="id" title="var">ev_SS</span> 0 <span class="id" title="var">ev_0</span>)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab14"></a><h4 class="section">Exercício: nível 2, opcional (ex_beautiful_Sn)</h4>
 Termine a definição do objeto demonstrador seguinte: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">p</span> : <span class="id" title="var">ex</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">beautiful</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) :=<br/>
 <span class="id" title="var">admit</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h1 class="section">Argumentos Explícitos para Lemas e Hipóteses</h1>

<div class="paragraph"> </div>

 Mesmo quando nós usamos demonstrações utilizando táticas, pode ser
    útil entender a natureza funcional subjacente das implicações e das
    quantificações.

<div class="paragraph"> </div>

    Por exemplo, é frequentemente conveniente aplicar <span class="inlinecode"><span class="id" title="tactic">apply</span></span> ou <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> com
    um lema o hipótese tendo um ou mais quantificadores já instanciados de forma
    a poder direcionar o resultado. Por exemplo: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">plus_comm</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">c</span> + (<span class="id" title="var">b</span> + <span class="id" title="var">a</span>) = <span class="id" title="var">c</span> + (<span class="id" title="var">a</span> + <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span>). &nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Neste caso, fornecer apenas um argumento teria sido suficiente. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm_r&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">c</span> + (<span class="id" title="var">b</span> + <span class="id" title="var">a</span>) = <span class="id" title="var">c</span> + (<span class="id" title="var">a</span> + <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Os argumentos devem ser listados na ordem, mas coringas (_)
    podem ser utilizados para pular argumentos que Coq pode deduzir.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm_r&acute;&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">c</span> + (<span class="id" title="var">b</span> + <span class="id" title="var">a</span>) = <span class="id" title="var">c</span> + (<span class="id" title="var">a</span> + <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">plus_comm</span> <span class="id" title="var">_</span> <span class="id" title="var">a</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
O autor de um lema pode escolher de declarar como implícitos os argumentos
    passíveis de serem deduzidos, da mesma forma que com funções e construtores.

<div class="paragraph"> </div>

    As cláusulas <span class="inlinecode"><span class="id" title="keyword">with</span></span> que já encontramos são apenas uma forma de especificar
    os argumentos selecionados por nome, e não por posição:  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_comm_r&acute;&acute;&acute;</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">c</span> + (<span class="id" title="var">b</span> + <span class="id" title="var">a</span>) = <span class="id" title="var">c</span> + (<span class="id" title="var">a</span> + <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">plus_comm</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">n</span> := <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h4 class="section">Exercício: nível 2 (trans_eq_example_redux)</h4>
 Refazer a demonstração do teorema seguinte (oriundo de MoreCoq.v) com um
    <span class="inlinecode"><span class="id" title="tactic">apply</span></span> de <span class="inlinecode"><span class="id" title="var">trans_eq</span></span> mas <i>sem  utilizar uma cláusula <span class="inlinecode"><span class="id" title="keyword">with</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">trans_eq_example&acute;</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span> <span class="id" title="var">e</span> <span class="id" title="var">f</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">a</span>;<span class="id" title="var">b</span>] = [<span class="id" title="var">c</span>;<span class="id" title="var">d</span>] →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">c</span>;<span class="id" title="var">d</span>] = [<span class="id" title="var">e</span>;<span class="id" title="var">f</span>] →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">a</span>;<span class="id" title="var">b</span>] = [<span class="id" title="var">e</span>;<span class="id" title="var">f</span>].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h1 class="section">Programação com Táticas (Avançado)</h1>

<div class="paragraph"> </div>

 Se podemos construir demonstrações com termos explícitos ao invés
    de táticas, talvez você está se questionando se podemos construir
    programas que utilizam táticas ao invés de termos explícitos.
    Certamente! 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">add1</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>
<span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">apply</span> <span class="id" title="var">S</span>.<br/>
<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">apply</span> <span class="id" title="var">n</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">add1</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">add1</span> 2.<br/>

<br/>
</div>

<div class="doc">
Note que terminamos com <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> com um <span class="inlinecode">.</span> ao invés de <span class="inlinecode">:=</span> seguido de
    um termo. Isso instrui Coq para entrar em modo de transcrição de
    demonstração de forma a construir um objeto do tipo <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Também
    terminamos a demonstração com <span class="inlinecode"><span class="id" title="keyword">Defined</span></span> ao invés de <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>; isto torna a
    definição <i>transparente  de tal forma que pode ser utilizado em computações
    como uma função definida de maneira usual.

<div class="paragraph"> </div>

    Esta possibilidade é principalmente útil para escrever funções com tipos
    dependentes, mas não adiantaremos muito mais este aspecto neste
    livro. Contudo é uma boa forma de ilustrar a uniformidade e ortogonalidade
    das ideias fundamentais em Coq. 
</div>
<div class="code">

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>