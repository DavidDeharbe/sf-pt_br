
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Embasamento: Programação Funcional em Coq</title>
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
</head>
<h1 class="libtitle">Library Preface</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Preface</h1>

<div class="paragraph"> </div>

<a name="lab2"></a><h1 class="section">Bem-vindo</h1>

<div class="paragraph"> </div>

 Esse livro eletrônico é um curso em Fundações de Software, a base
    base matemática de softwares confiáveis. Esse tópico inclui 
    conceitos básicos de lógica, prova de teoremas assistida por
    computador, o assistente de provas Coq, programação funcional,
    semântica operacional, lógica de Hoare e sistemas do tipo 
    estático. A leitura é direcionada a um grande conjunto de leitores,
    desde os graduandos avançados até estudantes de PhD e pesquisadores. 
    Nenhum conhecimento específico anterior em lógica ou linguagens de 
    programação é requisitado, porém uma certa maturidade em matemática
    será útil.

<div class="paragraph"> </div>

    A principal novidade no curso é que ele é cem por cento formalizado
    e verificado: o texto inteiro é literalmente um script para Coq. Ele
    é feito para ser lido juntamente com uma sessão interativa com Coq.
    Todos os detalhes do texto são totalmente formalizados em Coq, e os
    exercícios foram planejados para serem feitos usando o Coq.

<div class="paragraph"> </div>

    Os arquivos são organizados em uma sequencia de capítulos centrais,
    cobrindo por volta de um semestre de material e organizado em uma 
    narrativa linear e coerente, mais um número de apêndices envolvendo
    tópicos adicionais. Todos os capítulos centrais são adequados para 
    ambos os níveis de alunos, graduandos e graduados.
<div class="paragraph"> </div>

<a name="lab3"></a><h1 class="section">Overview</h1>

<div class="paragraph"> </div>

 Building reliable software is hard.  The scale and complexity of
    modern systems, the number of people involved in building them,
    and the range of demands placed on them make it extremely
    difficult even to build software that is more or less correct,
    much less to get it 100% correct.  At the same time, the
    increasing degree to which information processing is woven into
    every aspect of society continually amplifies the cost of bugs and
    insecurities.

<div class="paragraph"> </div>

    Computer scientists and software engineers have responded to these
    challenges by developing a whole host of techniques for improving
    software reliability, ranging from recommendations about managing
    software projects and organizing programming teams (e.g., extreme
    programming) to design philosophies for libraries (e.g.,
    model-view-controller, publish-subscribe, etc.) and programming
    languages (e.g., object-oriented programming, aspect-oriented
    programming, functional programming, ...) and to mathematical
    techniques for specifying and reasoning about properties of
    software and tools for helping validate these properties.

<div class="paragraph"> </div>

    The present course is focused on this last set of techniques.  The
    text weaves together five conceptual threads:

<div class="paragraph"> </div>

    (1) basic tools from <i>logic</i> for making and justifying precise
        claims about programs;

<div class="paragraph"> </div>

    (2) the use of <i>proof assistants</i> to construct rigorous logical
        arguments;

<div class="paragraph"> </div>

    (3) the idea of <i>functional programming</i>, both as a method of
        programming and as a bridge between programming and logic;

<div class="paragraph"> </div>

    (4) formal techniques for <i>reasoning about the properties of
        specific programs</i> (e.g., the fact that a loop terminates on
        all inputs, or that a sorting function or a compiler obeys a
        particular specification); and

<div class="paragraph"> </div>

    (5) the use of <i>type systems</i> for establishing well-behavedness
        guarantees for <i>all</i> programs in a given programming
        language (e.g., the fact that well-typed Java programs cannot
        be subverted at runtime).

<div class="paragraph"> </div>

    Each of these topics is easily rich enough to fill a whole course
    in its own right; taking all of them together naturally means that
    much will be left unsaid.  But we hope readers will find that the
    themes illuminate and amplify each other in useful ways, and that
    bringing them together creates a foundation from which it will be
    easy to dig into any of them more deeply.  Some suggestions for
    further reading can be found in the <span class="inlinecode"><span class="id" title="var">Postscript</span></span> chapter. 
<div class="paragraph"> </div>

<a name="lab4"></a><h2 class="section">Logic</h2>

<div class="paragraph"> </div>

 Logic is the field of study whose subject matter is <i>proofs</i> --
    unassailable arguments for the truth of particular propositions.
    Volumes have been written about the central role of logic in
    computer science.  Manna and Waldinger called it "the calculus of
    computer science," while Halpern et al.'s paper <i>On the Unusual
    Effectiveness of Logic in Computer Science</i> catalogs scores of
    ways in which logic offers critical tools and insights.  Indeed,
    they observe that "As a matter of fact, logic has turned out to be
    significiantly more effective in computer science than it has been
    in mathematics.  This is quite remarkable, especially since much
    of the impetus for the development of logic during the past one
    hundred years came from mathematics."

<div class="paragraph"> </div>

    In particular, the fundamental notion of inductive proofs is
    ubiquitous in all of computer science.  You have surely seen them
    before, in contexts from discrete math to analysis of algorithms,
    but in this course we will examine them much more deeply than you
    have probably done so far. 
<div class="paragraph"> </div>

<a name="lab5"></a><h2 class="section">Assistentes de Prova</h2>

<div class="paragraph"> </div>

 O fluxo de ideias entre a lógica e a Ciência da Computação não seguiu em uma
    única direção: a Ciência da Computação também realizou contribuições importantes para a lógica. Uma
    dessas foi o desenvolvimento de ferramentas de software para auxiliar na
    construção de provas de proposições lógicas. Essas ferramentas se dividem em
    duas grandes categorias:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Provadores automáticos de teoremas</i> fornecem a operação "push-button":

</li>
</ul>
    o operador entrega uma proposição e recebe em retorno <i>true</i> (verdadeiro), <i>false</i> (falso), ou <i>ran
    out of time</i> (estouro de tempo).  Apesar de suas capacidades serem limitadas para tipos bastante
    específicos de raciocínio, os provadores têm amadurecido tremendamente nos
    últimos anos e agora são utilizados em uma enorme variadade de configurações.
      Exemplos dessas ferramentas incluem solucionadores SAT, solucionadores SMT,
      e verificadores de modelo.

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Assistentes de Prova</i> são ferramentas híbridas que automatizam os mais

</li>
</ul>
    rotineiros aspectos dos construtores de prova enquanto dependem da
    orientação humana para aspectos mais difíceis. Assistentes de prova
    amplamente utilizados incluem Isabelle, Agda, Twelf, ACL2, PVS, e Coq, entre
    muitos outros.

<div class="paragraph"> </div>

    Esse curso é baseado em torno de Coq, um assistente de prova que tem
    estado em desenvolvimento desde 1983 por laboratórios franceses de
    pesquisas e universidades. Coq fornece um rico ambiente para
    desenvolvimento interativo de raciocínio formal com verificação de
    máquina. O núcleo do sistema Coq é um simples verificador de prova que
    garante que somente passos corretos de dedução sejam realizados. Além
    desse núcleo, o ambiente Coq prove facilidades de alto nível para
    desenvolvimento de prova, incluindo táticas poderosas para construção de
    provas complexas semi-automaticamente, além de uma grande biblioteca de
    definições comuns e lemas.

<div class="paragraph"> </div>

    Coq tem sido um fator crítico para uma grande variedade de trabalhos
    da Ciência da Computação e da Matemática:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Como uma <i>plataforma para modelagem de linguagem de programação</i>,

</li>
</ul>
    o Coq se tornou uma ferramenta padrão para pesquisadores que
    precisam descrever e raciocinar sobre definições de linguagens
    complexas. Foi utilizado, por exemplo, para verificar a segurança da
    plataforma JavaCard, obtendo o mais alto nível da certificação
    <i>common criteria</i>, e para especificações formais do x86 e dos
    conjuntos de instruções da LLVM.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Como um <i>ambiente para desenvolver software certificado

</li>
</ul>
    formalmente</i>, Coq foi utilizado para construir o CompCert, um
    otimizador de compilação totalmente verificado para C, para
    provar a exatidão de algoritmos sutis envolvendo números de
    ponto flutuante, e como a base para o Certicrypt, um ambiente
    para raciocínio sobre a segurança de algoritmos criptografados.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Como um <i>ambiente realista para programação com tipos dependentes</i>,

</li>
</ul>
    inspirando numerosas inovações. Por exemplo, o projeto Ynot em Harvard
    "raciocínio de Hoare relacional" (uma extensão da <i>lógica de Hoare</i> que
    veremos mais tarde nesse curso) em Coq.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Como um <i>assistente de prova para lógica de ordem superior</i>, foi utilizado

</li>
</ul>
    para validar uma série de resultados importantes na matemática. Por exemplo,
    sua capacidade de incluir computações complexas dentro de provas tornou
    possível desenvolver a primeira prova de teorema formalmente verificada do
    teorema das 4 cores. Essa prova havia sido controversa entre matemáticos
    porque parte dela inclui a verificação de um grande número de
    configurações usando um programa. Na formalização do Coq, tudo
    é verificado, incluindo a precisão da parte computacional. Mais
    recentemente, um esforço ainda maior levou à formalização através de Coq
    do teorema de Feit-Thompson -- o primeiro maior passo na classificação de
    grupos finitos simples.

<div class="paragraph"> </div>

    A propósito, caso você esteja se perguntando sobre o nome Coq, aqui está
    o que o website oficial diz: "Alguns cientistas franceses da computação têm
    a tradição de nomear seus software como espécies de animais: Caml, Elan, Foc
    ou Phox são exemplos dessa convenção. Em francês, 'coq' significa galo, e,
    além disso soa como as iniciais de Calculus of Constructions (CoC), no
    qual é baseado." O galo é um simbolo nacional da França, e "Coq" são as
    três primeiras letras do nome de Thierry Coquand, um dos primeiros
    desenvolvedores do Coq. 
<div class="paragraph"> </div>

<a name="lab6"></a><h2 class="section">Functional Programming</h2>

<div class="paragraph"> </div>

 The term <i>functional programming</i> refers both to a collection of
    programming idioms that can be used in almost any programming
    language and to a family of programming languages designed to
    emphasize these idioms, including Haskell, OCaml, Standard ML,
    F#, Scala, Scheme, Racket, Common Lisp, Clojure, Erlang, and Coq.

<div class="paragraph"> </div>

    Functional programming has been developed over many decades --
    indeed, its roots go back to Church's lambda-calculus, which was
    invented in the 1930s before the era of the computer began!  But
    since the early '90s it has enjoyed a surge of interest among
    industrial engineers and language designers, playing a key role in
    high-value systems at companies like Jane St. Capital, Microsoft,
    Facebook, and Ericsson.

<div class="paragraph"> </div>

    The most basic tenet of functional programming is that, as much as
    possible, computation should be <i>pure</i>, in the sense that the only
    effect of execution should be to produce a result: the computation
    should be free from <i>side effects</i> such as I/O, assignments to
    mutable variables, redirecting pointers, etc.  For example,
    whereas an <i>imperative</i> sorting function might take a list of
    numbers and rearrange its pointers to put the list in order, a
    pure sorting function would take the original list and return a
    <i>new</i> list containing the same numbers in sorted order.

<div class="paragraph"> </div>

    One significant benefit of this style of programming is that it
    makes programs easier to understand and reason about.  If every
    operation on a data structure yields a new data structure, leaving
    the old one intact, then there is no need to worry about how that
    structure is being shared and whether a change by one part of the
    program might break an invariant that another part of the program
    relies on.  These considerations are particularly critical in
    concurrent programs, where every piece of mutable state that is
    shared between threads is a potential source of pernicious bugs.
    Indeed, a large part of the recent interest in functional
    programming in industry is due to its simple behavior in the
    presence of concurrency.

<div class="paragraph"> </div>

    Another reason for the current excitement about functional
    programming is related to the first: functional programs are often
    much easier to parallelize than their imperative counterparts.  If
    running a computation has no effect other than producing a result,
    then it does not matter <i>where</i> it is run.  Similarly, if a data
    structure is never modified destructively, then it can be copied
    freely, across cores or across the network.  Indeed, the MapReduce
    idiom that lies at the heart of massively distributed query
    processors like Hadoop and is used by Google to index the entire
    web is a classic example of functional programming.

<div class="paragraph"> </div>

    For purposes of this course, functional programming has yet
    another significant attraction: it serves as a bridge between
    logic and computer science.  Indeed, Coq itself can be viewed as a
    combination of a small but extremely expressive functional
    programming language plus with a set of tools for stating and
    proving logical assertions.  Moreover, when we come to look more
    closely, we find that these two sides of Coq are actually aspects
    of the very same underlying machinery -- i.e., <i>proofs are
    programs</i>.  
<div class="paragraph"> </div>

<a name="lab7"></a><h2 class="section">Program Verification</h2>

<div class="paragraph"> </div>

 The first third of the book is devoted to developing the
    conceptual framework of logic and functional programming and
    gaining enough fluency with Coq to use it for modeling and
    reasoning about nontrivial artifacts.  From this point on, we
    increasingly turn our attention to two broad topics of critical
    importance to the enterprise of building reliable software (and
    hardware): techniques for proving specific properties of
    particular <i>programs</i> and for proving general properties of whole
    programming <i>languages</i>.

<div class="paragraph"> </div>

    For both of these, the first thing we need is a way of
    representing programs as mathematical objects, so we can talk
    about them precisely, and ways of describing their behavior in
    terms of mathematical functions or relations.  Our tools for these
    tasks are <i>abstract syntax</i> and <i>operational semantics</i>, a method
    of specifying the behavior of programs by writing abstract
    interpreters.  At the beginning, we work with operational
    semantics in the so-called "big-step" style, which leads to
    somewhat simpler and more readable definitions, in those cases
    where it is applicable.  Later on, we switch to a more detailed
    "small-step" style, which helps make some useful distinctions
    between different sorts of "nonterminating" program behaviors and
    which is applicable to a broader range of language features,
    including concurrency.

<div class="paragraph"> </div>

    The first programming language we consider in detail is <i>Imp</i>, a
    tiny toy language capturing the core features of conventional
    imperative programming: variables, assignment, conditionals, and
    loops. We study two different ways of reasoning about the
    properties of Imp programs.

<div class="paragraph"> </div>

    First, we consider what it means to say that two Imp programs are
    <i>equivalent</i> in the sense that they give the same behaviors for
    all initial memories.  This notion of equivalence then becomes a
    criterion for judging the correctness of <i>metaprograms</i> --
    programs that manipulate other programs, such as compilers and
    optimizers.  We build a simple optimizer for Imp and prove that it
    is correct.

<div class="paragraph"> </div>

    Second, we develop a methodology for proving that Imp programs
    satisfy formal specifications of their behavior.  We introduce the
    notion of <i>Hoare triples</i> -- Imp programs annotated with pre- and
    post-conditions describing what should be true about the memory in
    which they are started and what they promise to make true about
    the memory in which they terminate -- and the reasoning principles
    of <i>Hoare Logic</i>, a "domain-specific logic" specialized for
    convenient compositional reasoning about imperative programs, with
    concepts like "loop invariant" built in.

<div class="paragraph"> </div>

    This part of the course is intended to give readers a taste of the
    key ideas and mathematical tools used for a wide variety of
    real-world software and hardware verification tasks.

<div class="paragraph"> </div>

<a name="lab8"></a><h2 class="section">Sistemas de Tipo</h2>

<div class="paragraph"> </div>

 O nosso tópico final principal, cobrindo o último terço do curso, 
    é Sistemas de Tipo, um conjunto poderoso de ferramentas para
    estabelecer propriedade de todos os programas em uma dada 
    linguagem.

<div class="paragraph"> </div>

    Sistemas de tipos são os mais bem estabelecidos e populares 
    exemplos de uma classe bem sucedida de técnicas de verificação 
    formal, conhecida como métodos formais leves. Essas são técnicas
    de raciocínio de poder modesto -- modesto o suficiente a ponto de
    checadores automáticos poderem ser construídos em compiladores, 
    linkeditores, ou analisadores de programas e assim serem aplicadas até
    por programadores não familiarizados com as teorias básicas. (Outros
    exemplos de métodos formais leves incluem verificadores de modelos de 
    software e hardware, verificadores de contratos, e técnicas de 
    monitoramento em tempo de execução para detectar quando algum 
    componente de um sistema não está se comportando de acordo com a 
    especificação).

<div class="paragraph"> </div>

    Esse tópico fecha o círculo: a linguagem cujas propriedades nós 
    estudamos nessa parte, chamada de <i>cálculo-lambda simplesmente 
    tipado</i>, é essencialmente um modelo simplificado do Coq!

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab9"></a><h1 class="section">Practicalities</h1>

<div class="paragraph"> </div>

<a name="lab10"></a><h2 class="section">Dependências entre capítulos</h2>

<div class="paragraph"> </div>

 Um diagrama da dependência entre os capítulos e alguns caminhos
    sugeridos através do material pode ser encontrados no arquivo &lt;deps.html&gt;. 
<div class="paragraph"> </div>

<a name="lab11"></a><h2 class="section">System Requirements</h2>

<div class="paragraph"> </div>

 Coq runs on Windows, Linux, and OS X.  You will need:

<div class="paragraph"> </div>

<ul class="doclist">
<li> A current installation of Coq, available from the Coq home
         page.  Everything should work with version 8.4.

<div class="paragraph"> </div>


</li>
<li> An IDE for interacting with Coq.  Currently, there are two
         choices:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Proof General is an Emacs-based IDE.  It tends to be
             preferred by users who are already comfortable with
             Emacs.  It requires a separate installation (google
             "Proof General").

<div class="paragraph"> </div>


</li>
<li> CoqIDE is a simpler stand-alone IDE.  It is distributed
             with Coq, but on some platforms compiling it involves
             installing additional packages for GUI libraries and
             such. 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab12"></a><h2 class="section">Exercícios</h2>

<div class="paragraph"> </div>

 Cada capítulo inclui numerosos exercícios. Cada exercício é marcado
    com uma "classificação de estrelas," a qual pode ser interpretada
    da seguinte maneira:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Uma estrela: exercícios fáceis que ressaltam pontos no texto e
         que, para muitos leitores, deve tomar somente um ou dois 
         minutos. Crie o hábito de fazer esses exercícios no momento
         em que chegar neles.

<div class="paragraph"> </div>


</li>
<li> Duas estrelas: exercícios simples (cinco ou dez minutos).

<div class="paragraph"> </div>


</li>
<li> Três estrelas: exercícios que requerem um pouco mais de 
         raciocínio (de dez minutos a meia-hora).

<div class="paragraph"> </div>


</li>
<li> Quatro e cinco estrelas: exercícios mais difíceis (a partir de 
         meia-hora).

</li>
</ul>

<div class="paragraph"> </div>

    Além disso, alguns exercícios são marcados como "avançado", e alguns
    outros são marcados como "opcional." Fazer somente os exercícios
    não-opcionais e não-avançados deve proporcionar uma boa cobertura 
    do assunto central. Exercícios opcionais porporcionam um pouco mais 
    de prática com conceitos chaves e introduz temas secundários que 
    podem ser do interesse de alguns leitores. Exercícios avançados são 
    para leitores que querem um desafio extra (e, como retribuição, um
    contato mais profundo com o material).

<div class="paragraph"> </div>

    <i>Por favor, não publique soluções para os exercícios em locais 
    públicos</i>: Fundações de Software é largamente utilizado tanto para 
    estudos pessoais quanto para cursos universitários. Ter as soluções
    facilmente disponíveis torna o livro muito menos útil para cursos,
    os quais tem as atividades normalmente graduadas. Os autores 
    especialmente solicitam que os leitores não publiquem as soluções 
    para os exercícios em qualquer lugar que possa ser encontrado por
    mecanismos de busca.

<div class="paragraph"> </div>

<a name="lab13"></a><h2 class="section">Downloading the Coq Files</h2>

<div class="paragraph"> </div>

 A tar file containing the full sources for the "release version"
    of these notes (as a collection of Coq scripts and HTML files) is
    available here:
<pre>
        http://www.cis.upenn.edu/~bcpierce/sf   
</pre>
    If you are using the notes as part of a class, you may be given
    access to a locally extended version of the files, which you
    should use instead of the release version.

<div class="paragraph"> </div>

<a name="lab14"></a><h1 class="section">Nota para instrutores</h1>

<div class="paragraph"> </div>

 Se você pretende utilizar esse material em seu próprio curso, com certeza
    encontrará coisas que gostará de modificar, aprimorar ou adicionar.
    Suas contribuições são bem-vindas!

<div class="paragraph"> </div>

    Por favor, enviei um e-mail para Benjamin Pierce, descrevendo-se e
    informando como gostaria de fazer uso do material, incluindo o resultado
    de fazer "htpasswd -s -n NAME", onde NAME é seu nome de
    usuário.  Nós vamos configurar sua leitura/acesso com a nossa subversão do
    repositório e adiciona-lo na lista de contato de desenvolvedores; no repositório você encontrará
    um <span class="inlinecode"><span class="id" title="var">README</span></span> com futuras instruções. 
<div class="paragraph"> </div>

<a name="lab15"></a><h1 class="section">Translations</h1>

<div class="paragraph"> </div>

 Thanks to the efforts of a team of volunteer translators, <i>Software 
    Foundations</i> can now be enjoyed in Japanese at <span class="inlinecode"><span class="id" title="var">http</span>://<span class="id" title="var">proofcafe.org</span>/<span class="id" title="var">sf</span></span>

</div>
<div class="code">

<br/>
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>